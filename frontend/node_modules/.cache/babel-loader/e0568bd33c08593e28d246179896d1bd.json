{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst debug = logger.debugContext(\"connection:sqlite\");\n\nconst dataTypes = require(\"../../data-types\").sqlite;\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    if (this.sequelize.options.host === \"localhost\") {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule(\"sqlite3\");\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map(connection => promisify(callback => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || \"default\";\n\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0) {\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || \":memory:\";\n    }\n\n    options.inMemory = options.storage === \":memory:\" ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      fs.mkdirSync(path.dirname(options.storage), {\n        recursive: true\n      });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, err => {\n        if (err) return reject(new sequelizeErrors.ConnectionError(err));\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n\n    if (this.sequelize.config.password) {\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n\n    if (this.sequelize.options.foreignKeys !== false) {\n      connection.run(\"PRAGMA FOREIGN_KEYS=ON\");\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === \":memory:\" && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\sqlite\\connection-manager.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(\n      Object.getOwnPropertyNames(this.connections)\n        .map(connection => promisify(callback => this.connections[connection].close(callback))())\n    );\n    return super._onProcessExit.call(this);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== undefined) {\n      // Check explicitely for the storage option to not be set since an empty string signals\n      // SQLite will create a temporary disk-based database in that case.\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || ':memory:';\n    }\n\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        options.storage,\n        options.readWriteMode,\n        err => {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}