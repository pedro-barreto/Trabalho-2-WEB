{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst AbstractQuery = require(\"../abstract/query\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst debug = logger.debugContext(\"sql:sqlite\");\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n\n    let result = this.instance;\n\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n\n      return result;\n    }\n\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result2 => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = {\n            \"0\": false,\n            \"1\": true\n          }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n\n      return result;\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n\n        const query = this;\n\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n\n        await Promise.all(tableNames.map(tableName => new Promise(resolve2 => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n\n            resolve2();\n          });\n        })));\n      }\n\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n\n    return value;\n  }\n\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\":\n        {\n          if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err,\n              stack: errStack\n            });\n          }\n\n          let fields = [];\n          let match = err.message.match(/columns (.*?) are/);\n\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \");\n          } else {\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(\", \").map(columnWithTable => columnWithTable.split(\".\")[1]);\n            }\n          }\n\n          const errors = [];\n          let message = \"Validation error\";\n\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n          }\n\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields,\n            stack: errStack\n          });\n        }\n\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, {\n          stack: errStack\n        });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, {\n          stack: errStack\n        });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n\n    return \"all\";\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\sqlite\\query.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n        const query = this;\n        // cannot use arrow function here because the function is bound to the statement\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n        conn[method](sql, parameters, afterExecute);\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        // If we already have the metadata for the table, there's no need to ask for it again\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName =>\n          new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n              resolve();\n            });\n          })));\n      }\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (['PRIMARY', 'FOREIGN'].includes(constraint[1])) {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err, errStack) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT_UNIQUE':\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\n      case 'SQLITE_CONSTRAINT_TRIGGER':\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"]},"metadata":{},"sourceType":"script"}