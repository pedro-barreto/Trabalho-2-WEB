{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pool = void 0;\n\nconst Deferred_1 = require(\"./Deferred\");\n\nconst AggregateError_1 = require(\"./AggregateError\");\n\nclass Pool {\n  constructor(factory) {\n    this.log = false;\n\n    if (!factory.create) {\n      throw new Error('create function is required');\n    }\n\n    if (!factory.destroy) {\n      throw new Error('destroy function is required');\n    }\n\n    if (!factory.validate) {\n      throw new Error('validate function is required');\n    }\n\n    if (typeof factory.min !== 'number' || factory.min < 0 || factory.min !== Math.round(factory.min)) {\n      throw new Error('min must be an integer >= 0');\n    }\n\n    if (typeof factory.max !== 'number' || factory.max <= 0 || factory.max !== Math.round(factory.max)) {\n      throw new Error('max must be an integer > 0');\n    }\n\n    if (factory.min > factory.max) {\n      throw new Error('max is smaller than min');\n    }\n\n    if (factory.maxUses !== undefined && (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {\n      throw new Error('maxUses must be an integer >= 0');\n    }\n\n    this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n    this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n    this.reapIntervalMillis = factory.reapIntervalMillis || 1000;\n    this.maxUsesPerResource = factory.maxUses || Infinity;\n    this.log = factory.log || false;\n    this._factory = factory;\n    this._count = 0;\n    this._draining = false;\n    this._pendingAcquires = [];\n    this._inUseObjects = [];\n    this._availableObjects = [];\n    this._removeIdleScheduled = false;\n  }\n\n  get size() {\n    return this._count;\n  }\n\n  get name() {\n    return this._factory.name;\n  }\n\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  get using() {\n    return this._inUseObjects.length;\n  }\n\n  get waiting() {\n    return this._pendingAcquires.length;\n  }\n\n  get maxSize() {\n    return this._factory.max;\n  }\n\n  get minSize() {\n    return this._factory.min;\n  }\n\n  _log(message, level) {\n    if (typeof this.log === 'function') {\n      this.log(message, level);\n    } else if (this.log) {\n      console.log(`${level.toUpperCase()} pool ${this.name || ''} - ${message}`);\n    }\n  }\n\n  _removeIdle() {\n    const toRemove = [];\n    const now = Date.now();\n    let i;\n    let available = this._availableObjects.length;\n    const maxRemovable = this.size - this.minSize;\n    let timeout;\n    this._removeIdleScheduled = false;\n\n    for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n      timeout = this._availableObjects[i].timeout;\n\n      if (now >= timeout) {\n        this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');\n\n        toRemove.push(this._availableObjects[i].resource);\n      }\n    }\n\n    toRemove.forEach(this.destroy, this);\n    available = this._availableObjects.length;\n\n    if (available > 0) {\n      this._log('this._availableObjects.length=' + available, 'verbose');\n\n      this._scheduleRemoveIdle();\n    } else {\n      this._log('removeIdle() all objects removed', 'verbose');\n    }\n  }\n\n  _scheduleRemoveIdle() {\n    if (!this._removeIdleScheduled) {\n      this._removeIdleScheduled = true;\n      this._removeIdleTimer = setTimeout(() => {\n        this._removeIdle();\n      }, this.reapIntervalMillis);\n    }\n  }\n\n  _dispense() {\n    let wrappedResource = null;\n    const waitingCount = this._pendingAcquires.length;\n\n    this._log(`dispense() clients=${waitingCount} available=${this._availableObjects.length}`, 'info');\n\n    if (waitingCount < 1) {\n      return;\n    }\n\n    while (this._availableObjects.length > 0) {\n      this._log('dispense() - reusing obj', 'verbose');\n\n      wrappedResource = this._availableObjects[this._availableObjects.length - 1];\n\n      if (!this._factory.validate(wrappedResource.resource)) {\n        this.destroy(wrappedResource.resource);\n        continue;\n      }\n\n      this._availableObjects.pop();\n\n      this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);\n\n      const deferred = this._pendingAcquires.shift();\n\n      return deferred.resolve(wrappedResource.resource);\n    }\n\n    if (this.size < this.maxSize) {\n      this._createResource();\n    }\n  }\n\n  _createResource() {\n    this._count += 1;\n\n    this._log(`createResource() - creating obj - count=${this.size} min=${this.minSize} max=${this.maxSize}`, 'verbose');\n\n    this._factory.create().then(resource => {\n      const deferred = this._pendingAcquires.shift();\n\n      if (deferred) {\n        this._addResourceToInUseObjects(resource, 0);\n\n        deferred.resolve(resource);\n      } else {\n        this._addResourceToAvailableObjects(resource, 0);\n      }\n    }).catch(error => {\n      const deferred = this._pendingAcquires.shift();\n\n      this._count -= 1;\n      if (this._count < 0) this._count = 0;\n\n      if (deferred) {\n        deferred.reject(error);\n      }\n\n      process.nextTick(() => {\n        this._dispense();\n      });\n    });\n  }\n\n  _addResourceToAvailableObjects(resource, useCount) {\n    const wrappedResource = {\n      resource: resource,\n      useCount: useCount,\n      timeout: Date.now() + this.idleTimeoutMillis\n    };\n\n    this._availableObjects.push(wrappedResource);\n\n    this._dispense();\n\n    this._scheduleRemoveIdle();\n  }\n\n  _addResourceToInUseObjects(resource, useCount) {\n    const wrappedResource = {\n      resource: resource,\n      useCount: useCount\n    };\n\n    this._inUseObjects.push(wrappedResource);\n  }\n\n  _ensureMinimum() {\n    let i, diff;\n\n    if (!this._draining && this.size < this.minSize) {\n      diff = this.minSize - this.size;\n\n      for (i = 0; i < diff; i++) {\n        this._createResource();\n      }\n    }\n  }\n\n  acquire() {\n    if (this._draining) {\n      return Promise.reject(new Error('pool is draining and cannot accept work'));\n    }\n\n    const deferred = new Deferred_1.Deferred();\n    deferred.registerTimeout(this.acquireTimeoutMillis, () => {\n      this._pendingAcquires = this._pendingAcquires.filter(pending => pending !== deferred);\n    });\n\n    this._pendingAcquires.push(deferred);\n\n    this._dispense();\n\n    return deferred.promise();\n  }\n\n  release(resource) {\n    if (this._availableObjects.some(resourceWithTimeout => resourceWithTimeout.resource === resource)) {\n      this._log('release called twice for the same resource: ' + new Error().stack, 'error');\n\n      return;\n    }\n\n    const index = this._inUseObjects.findIndex(wrappedResource => wrappedResource.resource === resource);\n\n    if (index < 0) {\n      this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');\n\n      return;\n    }\n\n    const wrappedResource = this._inUseObjects[index];\n    wrappedResource.useCount += 1;\n\n    if (wrappedResource.useCount >= this.maxUsesPerResource) {\n      this._log('release() destroying obj - useCount:' + wrappedResource.useCount + ' maxUsesPerResource:' + this.maxUsesPerResource, 'verbose');\n\n      this.destroy(wrappedResource.resource);\n\n      this._dispense();\n    } else {\n      this._inUseObjects.splice(index, 1);\n\n      this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);\n    }\n  }\n\n  async destroy(resource) {\n    const available = this._availableObjects.length;\n    const using = this._inUseObjects.length;\n    this._availableObjects = this._availableObjects.filter(object => object.resource !== resource);\n    this._inUseObjects = this._inUseObjects.filter(object => object.resource !== resource);\n\n    if (available === this._availableObjects.length && using === this._inUseObjects.length) {\n      this._ensureMinimum();\n\n      return;\n    }\n\n    this._count -= 1;\n    if (this._count < 0) this._count = 0;\n\n    try {\n      await this._factory.destroy(resource);\n    } finally {\n      this._ensureMinimum();\n\n      if (!this._draining) {\n        process.nextTick(() => {\n          this._dispense();\n        });\n      }\n    }\n  }\n\n  drain() {\n    this._log('draining', 'info');\n\n    this._draining = true;\n\n    const check = callback => {\n      if (this._pendingAcquires.length > 0) {\n        this._dispense();\n\n        setTimeout(() => {\n          check(callback);\n        }, 100);\n        return;\n      }\n\n      if (this._availableObjects.length !== this._count) {\n        setTimeout(() => {\n          check(callback);\n        }, 100);\n        return;\n      }\n\n      callback();\n    };\n\n    return new Promise(resolve => check(resolve));\n  }\n\n  async destroyAllNow() {\n    this._log('force destroying all objects', 'info');\n\n    this._removeIdleScheduled = false;\n    clearTimeout(this._removeIdleTimer);\n\n    const resources = this._availableObjects.map(resource => resource.resource);\n\n    const errors = [];\n\n    for (const resource of resources) {\n      try {\n        await this.destroy(resource);\n      } catch (ex) {\n        this._log('Error destroying resource: ' + ex.stack, 'error');\n\n        errors.push(ex);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new AggregateError_1.AggregateError(errors);\n    }\n  }\n\n}\n\nexports.Pool = Pool;","map":{"version":3,"sources":["../src/Pool.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pool = void 0;\nconst Deferred_1 = require(\"./Deferred\");\nconst AggregateError_1 = require(\"./AggregateError\");\nclass Pool {\n    constructor(factory) {\n        this.log = false;\n        if (!factory.create) {\n            throw new Error('create function is required');\n        }\n        if (!factory.destroy) {\n            throw new Error('destroy function is required');\n        }\n        if (!factory.validate) {\n            throw new Error('validate function is required');\n        }\n        if (typeof factory.min !== 'number' ||\n            factory.min < 0 ||\n            factory.min !== Math.round(factory.min)) {\n            throw new Error('min must be an integer >= 0');\n        }\n        if (typeof factory.max !== 'number' ||\n            factory.max <= 0 ||\n            factory.max !== Math.round(factory.max)) {\n            throw new Error('max must be an integer > 0');\n        }\n        if (factory.min > factory.max) {\n            throw new Error('max is smaller than min');\n        }\n        if (factory.maxUses !== undefined &&\n            (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {\n            throw new Error('maxUses must be an integer >= 0');\n        }\n        this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n        this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n        this.reapIntervalMillis = factory.reapIntervalMillis || 1000;\n        this.maxUsesPerResource = factory.maxUses || Infinity;\n        this.log = factory.log || false;\n        this._factory = factory;\n        this._count = 0;\n        this._draining = false;\n        this._pendingAcquires = [];\n        this._inUseObjects = [];\n        this._availableObjects = [];\n        this._removeIdleScheduled = false;\n    }\n    get size() {\n        return this._count;\n    }\n    get name() {\n        return this._factory.name;\n    }\n    get available() {\n        return this._availableObjects.length;\n    }\n    get using() {\n        return this._inUseObjects.length;\n    }\n    get waiting() {\n        return this._pendingAcquires.length;\n    }\n    get maxSize() {\n        return this._factory.max;\n    }\n    get minSize() {\n        return this._factory.min;\n    }\n    _log(message, level) {\n        if (typeof this.log === 'function') {\n            this.log(message, level);\n        }\n        else if (this.log) {\n            console.log(`${level.toUpperCase()} pool ${this.name || ''} - ${message}`);\n        }\n    }\n    _removeIdle() {\n        const toRemove = [];\n        const now = Date.now();\n        let i;\n        let available = this._availableObjects.length;\n        const maxRemovable = this.size - this.minSize;\n        let timeout;\n        this._removeIdleScheduled = false;\n        for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n            timeout = this._availableObjects[i].timeout;\n            if (now >= timeout) {\n                this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');\n                toRemove.push(this._availableObjects[i].resource);\n            }\n        }\n        toRemove.forEach(this.destroy, this);\n        available = this._availableObjects.length;\n        if (available > 0) {\n            this._log('this._availableObjects.length=' + available, 'verbose');\n            this._scheduleRemoveIdle();\n        }\n        else {\n            this._log('removeIdle() all objects removed', 'verbose');\n        }\n    }\n    _scheduleRemoveIdle() {\n        if (!this._removeIdleScheduled) {\n            this._removeIdleScheduled = true;\n            this._removeIdleTimer = setTimeout(() => {\n                this._removeIdle();\n            }, this.reapIntervalMillis);\n        }\n    }\n    _dispense() {\n        let wrappedResource = null;\n        const waitingCount = this._pendingAcquires.length;\n        this._log(`dispense() clients=${waitingCount} available=${this._availableObjects.length}`, 'info');\n        if (waitingCount < 1) {\n            return;\n        }\n        while (this._availableObjects.length > 0) {\n            this._log('dispense() - reusing obj', 'verbose');\n            wrappedResource = this._availableObjects[this._availableObjects.length - 1];\n            if (!this._factory.validate(wrappedResource.resource)) {\n                this.destroy(wrappedResource.resource);\n                continue;\n            }\n            this._availableObjects.pop();\n            this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);\n            const deferred = this._pendingAcquires.shift();\n            return deferred.resolve(wrappedResource.resource);\n        }\n        if (this.size < this.maxSize) {\n            this._createResource();\n        }\n    }\n    _createResource() {\n        this._count += 1;\n        this._log(`createResource() - creating obj - count=${this.size} min=${this.minSize} max=${this.maxSize}`, 'verbose');\n        this._factory\n            .create()\n            .then((resource) => {\n            const deferred = this._pendingAcquires.shift();\n            if (deferred) {\n                this._addResourceToInUseObjects(resource, 0);\n                deferred.resolve(resource);\n            }\n            else {\n                this._addResourceToAvailableObjects(resource, 0);\n            }\n        })\n            .catch((error) => {\n            const deferred = this._pendingAcquires.shift();\n            this._count -= 1;\n            if (this._count < 0)\n                this._count = 0;\n            if (deferred) {\n                deferred.reject(error);\n            }\n            process.nextTick(() => {\n                this._dispense();\n            });\n        });\n    }\n    _addResourceToAvailableObjects(resource, useCount) {\n        const wrappedResource = {\n            resource: resource,\n            useCount: useCount,\n            timeout: Date.now() + this.idleTimeoutMillis,\n        };\n        this._availableObjects.push(wrappedResource);\n        this._dispense();\n        this._scheduleRemoveIdle();\n    }\n    _addResourceToInUseObjects(resource, useCount) {\n        const wrappedResource = {\n            resource: resource,\n            useCount: useCount,\n        };\n        this._inUseObjects.push(wrappedResource);\n    }\n    _ensureMinimum() {\n        let i, diff;\n        if (!this._draining && this.size < this.minSize) {\n            diff = this.minSize - this.size;\n            for (i = 0; i < diff; i++) {\n                this._createResource();\n            }\n        }\n    }\n    acquire() {\n        if (this._draining) {\n            return Promise.reject(new Error('pool is draining and cannot accept work'));\n        }\n        const deferred = new Deferred_1.Deferred();\n        deferred.registerTimeout(this.acquireTimeoutMillis, () => {\n            this._pendingAcquires = this._pendingAcquires.filter((pending) => pending !== deferred);\n        });\n        this._pendingAcquires.push(deferred);\n        this._dispense();\n        return deferred.promise();\n    }\n    release(resource) {\n        if (this._availableObjects.some((resourceWithTimeout) => resourceWithTimeout.resource === resource)) {\n            this._log('release called twice for the same resource: ' + new Error().stack, 'error');\n            return;\n        }\n        const index = this._inUseObjects.findIndex((wrappedResource) => wrappedResource.resource === resource);\n        if (index < 0) {\n            this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');\n            return;\n        }\n        const wrappedResource = this._inUseObjects[index];\n        wrappedResource.useCount += 1;\n        if (wrappedResource.useCount >= this.maxUsesPerResource) {\n            this._log('release() destroying obj - useCount:' +\n                wrappedResource.useCount +\n                ' maxUsesPerResource:' +\n                this.maxUsesPerResource, 'verbose');\n            this.destroy(wrappedResource.resource);\n            this._dispense();\n        }\n        else {\n            this._inUseObjects.splice(index, 1);\n            this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);\n        }\n    }\n    async destroy(resource) {\n        const available = this._availableObjects.length;\n        const using = this._inUseObjects.length;\n        this._availableObjects = this._availableObjects.filter((object) => object.resource !== resource);\n        this._inUseObjects = this._inUseObjects.filter((object) => object.resource !== resource);\n        if (available === this._availableObjects.length &&\n            using === this._inUseObjects.length) {\n            this._ensureMinimum();\n            return;\n        }\n        this._count -= 1;\n        if (this._count < 0)\n            this._count = 0;\n        try {\n            await this._factory.destroy(resource);\n        }\n        finally {\n            this._ensureMinimum();\n            if (!this._draining) {\n                process.nextTick(() => {\n                    this._dispense();\n                });\n            }\n        }\n    }\n    drain() {\n        this._log('draining', 'info');\n        this._draining = true;\n        const check = (callback) => {\n            if (this._pendingAcquires.length > 0) {\n                this._dispense();\n                setTimeout(() => {\n                    check(callback);\n                }, 100);\n                return;\n            }\n            if (this._availableObjects.length !== this._count) {\n                setTimeout(() => {\n                    check(callback);\n                }, 100);\n                return;\n            }\n            callback();\n        };\n        return new Promise((resolve) => check(resolve));\n    }\n    async destroyAllNow() {\n        this._log('force destroying all objects', 'info');\n        this._removeIdleScheduled = false;\n        clearTimeout(this._removeIdleTimer);\n        const resources = this._availableObjects.map((resource) => resource.resource);\n        const errors = [];\n        for (const resource of resources) {\n            try {\n                await this.destroy(resource);\n            }\n            catch (ex) {\n                this._log('Error destroying resource: ' + ex.stack, 'error');\n                errors.push(ex);\n            }\n        }\n        if (errors.length > 0) {\n            throw new AggregateError_1.AggregateError(errors);\n        }\n    }\n}\nexports.Pool = Pool;\n"]},"metadata":{},"sourceType":"script"}