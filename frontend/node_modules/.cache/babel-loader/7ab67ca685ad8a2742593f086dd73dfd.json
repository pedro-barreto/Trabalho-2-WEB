{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst Utils = require(\"../../utils\");\n\nconst Transaction = require(\"../../transaction\");\n\nconst _ = require(\"lodash\");\n\nconst MySqlQueryGenerator = require(\"../mysql/query-generator\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return \"SELECT sqlite_version() as `version`\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes(\"PRIMARY KEY\")).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes(\"AUTOINCREMENT\");\n        let dataTypeString = dataType;\n\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          if (dataType.includes(\"INT\")) {\n            dataTypeString = containsAutoIncrement ? \"INTEGER PRIMARY KEY AUTOINCREMENT\" : \"INTEGER PRIMARY KEY\";\n\n            if (dataType.includes(\" REFERENCES\")) {\n              dataTypeString += dataType.substr(dataType.indexOf(\" REFERENCES\"));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n\n            if (dataType.includes(\"NOT NULL\")) {\n              dataTypeString = dataType.replace(\" PRIMARY KEY\", \"\");\n            } else {\n              dataTypeString = dataType.replace(\"PRIMARY KEY\", \"NOT NULL\");\n            }\n          }\n        }\n\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    return hasJsonFunction;\n  }\n\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n\n    return value;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, {\n      context: \"addColumn\"\n    });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        }, bindParam)}`);\n      }\n    }\n\n    let query;\n\n    const whereOptions = __spreadProps(__spreadValues({}, options), {\n      bindParam\n    });\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return {\n      query,\n      bind\n    };\n  }\n\n  truncateTableQuery(tableName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return [`DELETE FROM ${this.quoteTable(tableName)}`, options.restartIdentity ? `; DELETE FROM ${this.quoteTable(\"sqlite_sequence\")} WHERE ${this.quoteIdentifier(\"name\")} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), \"`\"), \"'\")};` : \"\"].join(\"\");\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, \"allowNull\") && !dataType.allowNull) {\n          sql += \" NOT NULL\";\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += \" UNIQUE\";\n        }\n\n        if (dataType.primaryKey) {\n          sql += \" PRIMARY KEY\";\n\n          if (dataType.autoIncrement) {\n            sql += \" AUTOINCREMENT\";\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier(\"id\");\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(\", \");\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"-- SQLite is not able to choose the isolation level REPEATABLE READ.\";\n\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return \"PRAGMA read_uncommitted = ON;\";\n\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"PRAGMA read_uncommitted = OFF;\";\n\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, \"DEFAULT 0\").replace(/DEFAULT '?true'?/g, \"DEFAULT 1\");\n  }\n\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n\n}\n\nmodule.exports = SQLiteQueryGenerator;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\sqlite\\query-generator.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = { ...options, bindParam };\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  }\n\n}\n\nmodule.exports = SQLiteQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}