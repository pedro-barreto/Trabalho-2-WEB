{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst DataTypes = require(\"./data-types\");\n\nconst SqlString = require(\"./sql-string\");\n\nconst _ = require(\"lodash\");\n\nconst baseIsNative = require(\"lodash/_baseIsNative\");\n\nconst uuidv1 = require(\"uuid\").v1;\n\nconst uuidv4 = require(\"uuid\").v4;\n\nconst operators = require(\"./operators\");\n\nconst operatorsSet = new Set(Object.values(operators));\n\nlet inflection = require(\"inflection\");\n\nexports.classToInvokable = require(\"./utils/class-to-invokable\").classToInvokable;\nexports.joinSQLFragments = require(\"./utils/join-sql-fragments\").joinSQLFragments;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\n\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\n\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\n\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return [\"string\", \"number\", \"boolean\"].includes(type);\n}\n\nexports.isPrimitive = isPrimitive;\n\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    if (!_.isPlainObject(objectValue) && objectValue !== void 0) {\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n\n      return objectValue;\n    }\n  });\n}\n\nexports.mergeDefaults = mergeDefaults;\n\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== void 0) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\n\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\n\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\n\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\n\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\n\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\n\nexports.pluralize = pluralize;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\n\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\n\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return void 0;\n    }\n\n    if (onlyPlain || typeof elem === \"object\") {\n      return elem;\n    }\n\n    if (elem && typeof elem.clone === \"function\") {\n      return elem.clone();\n    }\n  });\n}\n\nexports.cloneDeep = cloneDeep;\n\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n  return options;\n}\n\nexports.mapFinderOptions = mapFinderOptions;\n\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      if (typeof attr !== \"string\") return attr;\n\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\n\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n    });\n  }\n\n  return attributes;\n}\n\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== void 0 && !Model._virtualAttributes.has(attr)) {\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\n\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === \"string\" && value[0] === \"$\" && value[value.length - 1] === \"$\";\n}\n\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\n\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\n\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === \"function\") {\n    const tmp = value();\n\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n\n    return tmp;\n  }\n\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n\n  if (_.isPlainObject(value)) {\n    return __spreadValues({}, value);\n  }\n\n  return value;\n}\n\nexports.toDefaultValue = toDefaultValue;\n\nfunction defaultValueSchemable(value) {\n  if (value === void 0) {\n    return false;\n  }\n\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n\n  return typeof value !== \"function\";\n}\n\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith(\"Id\") || val !== null && val !== void 0) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\n\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\nconst dialects = /* @__PURE__ */new Set([\"mariadb\", \"mysql\", \"postgres\", \"sqlite\", \"mssql\", \"db2\"]);\n\nfunction now(dialect) {\n  const d = new Date();\n\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n\n  return d;\n}\n\nexports.now = now;\nconst TICK_CHAR = \"`\";\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\n\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, \"g\"), \"\");\n}\n\nexports.removeTicks = removeTicks;\n\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n\n      if (typeof obj[key] === \"object\" && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, void 0);\n}\n\nexports.flattenObjectDeep = flattenObjectDeep;\n\nclass SequelizeMethod {}\n\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n\n}\n\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col) {\n    super();\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (args.length > 0) {\n      col = args;\n    }\n\n    this.col = col;\n  }\n\n}\n\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || \"\").trim();\n    this.json = json || false;\n  }\n\n}\n\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n\n}\n\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n\n}\n\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n\n    if (logic === void 0) {\n      logic = comparator;\n      comparator = \"=\";\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n\n}\n\nexports.Where = Where;\n\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\n\nexports.getOperators = getOperators;\n\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\n\nexports.getComplexKeys = getComplexKeys;\n\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\n\nexports.getComplexSize = getComplexSize;\n\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\n\nexports.isWhereEmpty = isWhereEmpty;\n\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\n\nexports.generateEnumName = generateEnumName;\n\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\n\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\nfunction defaults(object) {\n  object = Object(object);\n\n  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    sources[_key2 - 1] = arguments[_key2];\n  }\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n\n        if (value === void 0 || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n  return object;\n}\n\nexports.defaults = defaults;\n\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n\n  if (!Object.prototype.hasOwnProperty.call(index, \"name\")) {\n    const fields = index.fields.map(field => typeof field === \"string\" ? field : field.name || field.attribute);\n    index.name = underscore(`${tableName}_${fields.join(\"_\")}`);\n  }\n\n  return index;\n}\n\nexports.nameIndex = nameIndex;\n\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\n\nexports.intersects = intersects;\n\nfunction safeStringifyJson(value) {\n  return JSON.stringify(value, (key, value2) => {\n    if (typeof value2 === \"bigint\") {\n      return String(value2);\n    }\n\n    return value2;\n  });\n}\n\nexports.safeStringifyJson = safeStringifyJson;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\utils.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash');\nconst baseIsNative = require('lodash/_baseIsNative');\nconst uuidv1 = require('uuid').v1;\nconst uuidv4 = require('uuid').v4;\nconst operators = require('./operators');\nconst operatorsSet = new Set(Object.values(operators));\n\nlet inflection = require('inflection');\n\nexports.classToInvokable = require('./utils/class-to-invokable').classToInvokable;\nexports.joinSQLFragments = require('./utils/join-sql-fragments').joinSQLFragments;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return ['string', 'number', 'boolean'].includes(type);\n}\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      // _.isNative includes a check for core-js and throws an error if present.\n      // Depending on _baseIsNative bypasses the core-js check.\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== undefined) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    }\n\n    // If we specified to clone only plain objects & arrays, we ignore everyhing else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr;\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n\n    });\n  }\n\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';\n}\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (_.isPlainObject(value)) {\n    return { ...value };\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @returns {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (value === undefined) { return false; }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) { return false; }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n  return typeof value !== 'function';\n}\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nconst dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql', 'db2']);\n\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {object} value an Object\n * @returns {object} a flattened object\n * @private\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n *\n * @private\n */\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\n\n//Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n *\n * @param  {object} obj\n * @returns {Array<symbol>} All operators properties of obj\n * @private\n */\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\n\n/**\n * getComplexKeys\n *\n * @param  {object} obj\n * @returns {Array<string|symbol>} All keys including operators\n * @private\n */\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\n\n/**\n * getComplexSize\n *\n * @param  {object|Array} obj\n * @returns {number}      Length of object properties including operators if obj is array returns its length\n * @private\n */\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\n\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {object} obj\n * @returns {boolean}\n * @private\n */\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\n\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {string} tableName\n * @param {string} columnName\n * @returns {string}\n * @private\n */\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\n\n/**\n * Returns an new Object which keys are camelized\n *\n * @param {object} obj\n * @returns {string}\n * @private\n */\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {object} object The destination object.\n * @param {...object} [sources] The source objects.\n * @returns {object} Returns `object`.\n * @private\n */\nfunction defaults(object, ...sources) {\n  object = Object(object);\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n        if (\n          value === undefined ||\n            _.eq(value, Object.prototype[key]) &&\n            !Object.prototype.hasOwnProperty.call(object, key)\n\n        ) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n\n  return object;\n}\nexports.defaults = defaults;\n\n/**\n *\n * @param {object} index\n * @param {Array}  index.fields\n * @param {string} [index.name]\n * @param {string|object} tableName\n *\n * @returns {object}\n * @private\n */\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(\n      field => typeof field === 'string' ? field : field.name || field.attribute\n    );\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\nexports.nameIndex = nameIndex;\n\n/**\n * Checks if 2 arrays intersect.\n *\n * @param {Array} arr1\n * @param {Array} arr2\n * @private\n */\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\nexports.intersects = intersects;\n\n/**\n * Stringify a value as JSON with some differences:\n * - bigints are stringified as a json string. (`safeStringifyJson({ val: 1n })` outputs `'{ \"val\": \"1\" }'`).\n *   This is because of a decision by TC39 to not support bigint in JSON.stringify https://github.com/tc39/proposal-bigint/issues/24\n *\n * @param {any} value the value to stringify.\n * @returns {string} the resulting json.\n */\nfunction safeStringifyJson(value /* : any */) /* : string */ {\n  return JSON.stringify(value, (key, value) => {\n    if (typeof value === 'bigint') {\n      return String(value);\n    }\n\n    return value;\n  });\n}\n\nexports.safeStringifyJson = safeStringifyJson;\n"]},"metadata":{},"sourceType":"script"}