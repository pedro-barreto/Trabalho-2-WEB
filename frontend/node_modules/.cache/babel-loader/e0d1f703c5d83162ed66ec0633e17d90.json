{"ast":null,"code":"\"use strict\";\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst DataTypes = require(\"../../data-types\").db2;\n\nconst debug = logger.debugContext(\"connection:db2\");\n\nconst parserStore = require(\"../parserStore\")(\"db2\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"ibm_db\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n\n    if (config.ssl) {\n      connectionConfig[\"security\"] = config.ssl;\n    }\n\n    if (config.sslcertificate) {\n      connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n    }\n\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = new this.lib.Database();\n        connection2.lib = this.lib;\n        connection2.open(connectionConfig, error => {\n          if (error) {\n            if (error.message && error.message.includes(\"SQL30081N\")) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n\n          return resolve(connection2);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n\n  disconnect(connection) {\n    if (connection.connected) {\n      connection.close(error => {\n        if (error) {\n          debug(error);\n        } else {\n          debug(\"connection closed\");\n        }\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  validate(connection) {\n    return connection && connection.connected;\n  }\n\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\db2\\connection-manager.js"],"names":[],"mappings":";;AAEA,MAAM,yBAAA,GAA4B,OAAA,CAAQ,gCAAR,CAAlC;;AACA,MAAM,eAAA,GAAkB,OAAA,CAAQ,cAAR,CAAxB;;AACA,MAAM;AAAE,EAAA;AAAF,IAAa,OAAA,CAAQ,oBAAR,CAAnB;;AACA,MAAM,SAAA,GAAY,OAAA,CAAQ,kBAAR,CAAA,CAA4B,GAA9C;;AACA,MAAM,KAAA,GAAQ,MAAA,CAAO,YAAP,CAAoB,gBAApB,CAAd;;AACA,MAAM,WAAA,GAAc,OAAA,CAAQ,gBAAR,CAAA,CAA0B,KAA1B,CAApB;;AAWA,MAAA,iBAAA,SAAgC,yBAAhC,CAA0D;AACxD,EAAA,WAAA,CAAY,OAAZ,EAAqB,SAArB,EAAgC;AAC9B,IAAA,SAAA,CAAU,MAAV,CAAiB,IAAjB,GAAwB,SAAA,CAAU,MAAV,CAAiB,IAAjB,IAAyB,IAAjD;AACA,UAAM,OAAN,EAAe,SAAf;AACA,SAAK,GAAL,GAAW,KAAK,kBAAL,CAAwB,QAAxB,CAAX;AACA,SAAK,iBAAL,CAAuB,SAAvB;AAAuB;;AAGlB,SAAA,SAAA,CAAU,KAAV,EAAiB,IAAjB,EAAuB;AAC5B,QAAI,WAAA,CAAY,GAAZ,CAAgB,KAAA,CAAM,IAAtB,CAAJ,EAAiC;AAC/B,aAAO,WAAA,CAAY,GAAZ,CAAgB,KAAA,CAAM,IAAtB,EAA4B,KAA5B,EAAmC,KAAK,SAAL,CAAe,OAAlD,EAA2D,IAA3D,CAAP;AAAkE;;AAEpE,WAAO,IAAA,EAAP;AAAO;;AAGT,EAAA,kBAAA,CAAmB,QAAnB,EAA6B;AAC3B,IAAA,WAAA,CAAY,OAAZ,CAAoB,QAApB;AAAoB;;AAGtB,EAAA,gBAAA,GAAmB;AACjB,IAAA,WAAA,CAAY,KAAZ;AAAY;;AAYR,QAAA,OAAA,CAAQ,MAAR,EAAgB;AACpB,UAAM,gBAAA,GAAmB;AACvB,MAAA,QAAA,EAAU,MAAA,CAAO,QADM;AAEvB,MAAA,QAAA,EAAU,MAAA,CAAO,IAFM;AAGvB,MAAA,IAAA,EAAM,MAAA,CAAO,IAHU;AAIvB,MAAA,GAAA,EAAK,MAAA,CAAO,QAJW;AAKvB,MAAA,GAAA,EAAK,MAAA,CAAO;AALW,KAAzB;;AAQA,QAAI,MAAA,CAAO,GAAX,EAAgB;AACd,MAAA,gBAAA,CAAiB,UAAjB,CAAA,GAA+B,MAAA,CAAO,GAAtC;AAAsC;;AAExC,QAAI,MAAA,CAAO,cAAX,EAA2B;AACzB,MAAA,gBAAA,CAAiB,sBAAjB,CAAA,GAA2C,MAAA,CAAO,cAAlD;AAAkD;;AAEpD,QAAI,MAAA,CAAO,cAAX,EAA2B;AACzB,WAAA,MAAW,GAAX,IAAkB,MAAA,CAAO,IAAP,CAAY,MAAA,CAAO,cAAnB,CAAlB,EAAsD;AACpD,QAAA,gBAAA,CAAiB,GAAjB,CAAA,GAAwB,MAAA,CAAO,cAAP,CAAsB,GAAtB,CAAxB;AAA8C;AAAA;;AAIlD,QAAI;AACF,YAAM,UAAA,GAAa,MAAM,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAqB;AACxD,cAAM,WAAA,GAAa,IAAI,KAAK,GAAL,CAAS,QAAb,EAAnB;AACA,QAAA,WAAA,CAAW,GAAX,GAAiB,KAAK,GAAtB;AACA,QAAA,WAAA,CAAW,IAAX,CAAgB,gBAAhB,EAAkC,KAAA,IAAS;AACzC,cAAI,KAAJ,EAAW;AACT,gBAAI,KAAA,CAAM,OAAN,IAAiB,KAAA,CAAM,OAAN,CAAc,QAAd,CAAuB,WAAvB,CAArB,EAA0D;AACxD,qBAAO,MAAA,CAAO,IAAI,eAAA,CAAgB,sBAApB,CAA2C,KAA3C,CAAP,CAAP;AAAyD;;AAE3D,mBAAO,MAAA,CAAO,IAAI,eAAA,CAAgB,eAApB,CAAoC,KAApC,CAAP,CAAP;AAAkD;;AAEpD,iBAAO,OAAA,CAAQ,WAAR,CAAP;AAAe,SAPjB;AAOiB,OAVM,CAAzB;AAaA,aAAO,UAAP;AAAO,KAdT,CAcS,OACA,GADA,EACP;AACA,YAAM,IAAI,eAAA,CAAgB,eAApB,CAAoC,GAApC,CAAN;AAA0C;AAAA;;AAI9C,EAAA,UAAA,CAAW,UAAX,EAAuB;AAErB,QAAI,UAAA,CAAW,SAAf,EAA0B;AACxB,MAAA,UAAA,CAAW,KAAX,CAAiB,KAAA,IAAS;AACxB,YAAI,KAAJ,EAAW;AAAE,UAAA,KAAA,CAAM,KAAN,CAAA;AAAM,SAAnB,MACK;AAAE,UAAA,KAAA,CAAM,mBAAN,CAAA;AAAM;AAAA,OAFf;AAEe;;AAGjB,WAAO,OAAA,CAAQ,OAAR,EAAP;AAAe;;AAGjB,EAAA,QAAA,CAAS,UAAT,EAAqB;AACnB,WAAO,UAAA,IAAc,UAAA,CAAW,SAAhC;AAAgC;;AAUlC,EAAA,WAAA,CAAY,UAAZ,EAAwB;AACtB,WAAO,KAAK,OAAL,CAAa,iBAAb,CAA+B,UAA/B,CAA0C,UAA1C,CAAP;AAAiD;;AAhGK;;AAoG1D,MAAA,CAAO,OAAP,GAAiB,iBAAjB;AACA,MAAA,CAAO,OAAP,CAAe,iBAAf,GAAmC,iBAAnC;AACA,MAAA,CAAO,OAAP,CAAe,OAAf,GAAyB,iBAAzB","sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst sequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').db2;\nconst debug = logger.debugContext('connection:db2');\nconst parserStore = require('../parserStore')('db2');\n\n/**\n * DB2 Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle DB2 specific connections\n * Use https://github.com/ibmdb/node-ibm_db to connect with DB2 server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('ibm_db');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with DB2 database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n\n    if (config.ssl) {\n      connectionConfig['security'] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig['SSLServerCertificate'] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection = new this.lib.Database();\n        connection.lib = this.lib;\n        connection.open(connectionConfig, error => {\n          if (error) {\n            if (error.message && error.message.includes('SQL30081N')) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n\n  disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.connected) {\n      connection.close(error => {\n        if (error) { debug(error); }\n        else { debug('connection closed'); }\n      });\n    }\n    return Promise.resolve();\n  }\n\n  validate(connection) {\n    return connection && connection.connected;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}