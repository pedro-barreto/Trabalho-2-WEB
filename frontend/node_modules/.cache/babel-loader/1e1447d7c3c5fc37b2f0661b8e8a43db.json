{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst Op = require(\"../../operators\");\n\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n\n        wheres.push(where);\n      }\n    }\n\n    where = {\n      [Op.or]: wheres\n    };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n\n    if (options.indexes) {\n      options.indexes.forEach(fields => {\n        const fieldArr = fields.fields;\n\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields => {\n          const fieldArr = fields.fields;\n\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\"\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.Db2QueryInterface = Db2QueryInterface;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\db2\\query-interface.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst Op = require('../../operators');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk with Db2 database\n */\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine unique keys and indexes into one\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n\n    where = { [Op.or]: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, undefined];\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );  \n    if (options.indexes) {\n      options.indexes.forEach(fields=>{\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field=>{       \n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields=>{\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field=>{       \n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.Db2QueryInterface = Db2QueryInterface;\n"]},"metadata":{},"sourceType":"script"}