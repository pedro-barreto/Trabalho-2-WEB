{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst Utils = require(\"./../utils\");\n\nconst Helpers = require(\"./helpers\");\n\nconst _ = require(\"lodash\");\n\nconst Association = require(\"./base\");\n\nconst Op = require(\"../operators\");\n\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"BelongsTo\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([this.as, this.target.primaryKeyAttribute].join(\"_\"));\n    }\n\n    this.identifier = this.foreignKey;\n\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n\n    if (this.options.targetKey && !this.target.rawAttributes[this.options.targetKey]) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? \"SET NULL\" : \"NO ACTION\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n    this.source.refreshAttributes();\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n\n      for (const _instance of instances) {\n        result[_instance.get(this.foreignKey, {\n          raw: true\n        })] = null;\n      }\n\n      for (const _instance of results) {\n        result[_instance.get(this.targetKey, {\n          raw: true\n        })] = _instance;\n      }\n\n      return result;\n    }\n\n    return Target.findOne(options);\n  }\n\n  async set(sourceInstance, associatedInstance) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let value = associatedInstance;\n\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n\n    sourceInstance.set(this.foreignKey, value);\n    if (options.save === false) return;\n    options = __spreadValues({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options);\n    return await sourceInstance.save(options);\n  }\n\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    const newAssociatedObject = await this.target.create(values, options);\n    await sourceInstance[this.accessors.set](newAssociatedObject, options);\n    return newAssociatedObject;\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n\n}\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\associations\\belongs-to.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @see {@link Model.belongsTo}\n */\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'BelongsTo';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.as,\n          this.target.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n\n    if (\n      this.options.targetKey\n      && !this.target.rawAttributes[this.options.targetKey]\n    ) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  // the id is in the source table\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: {\n        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n        allowNull: true,\n        ...this.foreignKeyAttribute\n      }\n    };\n\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n\n    this.source.refreshAttributes();\n\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {object}         [options] find options\n   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.\n   * @param {string}         [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.foreignKey, { raw: true })] = null;\n      }\n\n      for (const _instance of results) {\n        result[_instance.get(this.targetKey, { raw: true })] = _instance;\n      }\n\n      return result;\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?Model|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {object} [options={}] options passed to `this.save`\n   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.\n   *\n   *  @returns {Promise}\n   */\n  async set(sourceInstance, associatedInstance, options = {}) {\n    let value = associatedInstance;\n\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n\n    sourceInstance.set(this.foreignKey, value);\n\n    if (options.save === false) return;\n\n    options = {\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true,\n      ...options\n    };\n\n    // passes the changed field to save, so only that field get updated.\n    return await sourceInstance.save(options);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {object} [values={}] values to create associated model instance with\n   * @param {object} [options={}] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create}  for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    const newAssociatedObject = await this.target.create(values, options);\n    await sourceInstance[this.accessors.set](newAssociatedObject, options);\n\n    return newAssociatedObject;\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;\n"]},"metadata":{},"sourceType":"script"}