{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\n\nvar __export = (target, all) => {\n  __markAsModule(target);\n\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\n__export(exports, {\n  JoinSQLFragmentsError: () => JoinSQLFragmentsError,\n  joinSQLFragments: () => joinSQLFragments\n});\n\nfunction doesNotWantLeadingSpace(str) {\n  return /^[;,)]/.test(str);\n}\n\nfunction doesNotWantTrailingSpace(str) {\n  return /\\($/.test(str);\n}\n\nfunction singleSpaceJoinHelper(parts) {\n  return parts.reduce((_ref, part) => {\n    let {\n      skipNextLeadingSpace,\n      result\n    } = _ref;\n\n    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {\n      result += part.trim();\n    } else {\n      result += ` ${part.trim()}`;\n    }\n\n    return {\n      skipNextLeadingSpace: doesNotWantTrailingSpace(part),\n      result\n    };\n  }, {\n    skipNextLeadingSpace: true,\n    result: \"\"\n  }).result;\n}\n\nfunction joinSQLFragments(array) {\n  if (array.length === 0) return \"\";\n  const truthyArray = array.filter(x => !!x);\n  const flattenedArray = truthyArray.map(fragment => {\n    if (Array.isArray(fragment)) {\n      return joinSQLFragments(fragment);\n    }\n\n    return fragment;\n  });\n\n  for (const fragment of flattenedArray) {\n    if (fragment && typeof fragment !== \"string\") {\n      throw new JoinSQLFragmentsError(flattenedArray, fragment, `Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);\n    }\n  }\n\n  const trimmedArray = flattenedArray.map(x => x.trim());\n  const nonEmptyStringArray = trimmedArray.filter(x => x !== \"\");\n  return singleSpaceJoinHelper(nonEmptyStringArray);\n}\n\nclass JoinSQLFragmentsError extends TypeError {\n  constructor(args, fragment, message) {\n    super(message);\n\n    __publicField(this, \"args\");\n\n    __publicField(this, \"fragment\");\n\n    this.args = args;\n    this.fragment = fragment;\n    this.name = \"JoinSQLFragmentsError\";\n  }\n\n}","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\utils\\join-sql-fragments.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,QAAA,CAAA,OAAA,EAAA;AAAA,EAAA,qBAAA,EAAA,MAAA,qBAAA;AAAA,EAAA,gBAAA,EAAA,MAAA;AAAA,CAAA,CAAA;;AAEA,SAAA,uBAAA,CAAiC,GAAjC,EAAuD;AACrD,SAAO,SAAS,IAAT,CAAc,GAAd,CAAP;AAAqB;;AAEvB,SAAA,wBAAA,CAAkC,GAAlC,EAAwD;AACtD,SAAO,MAAM,IAAN,CAAW,GAAX,CAAP;AAAkB;;AAcpB,SAAA,qBAAA,CAA+B,KAA/B,EAAwD;AACtD,SAAO,KAAA,CAAM,MAAN,CACL,OAAmC,IAAnC,KAA4C;AAAA,QAA3C;AAAE,MAAA,oBAAF;AAAwB,MAAA;AAAxB,KAA2C;;AAC1C,QAAI,oBAAA,IAAwB,uBAAA,CAAwB,IAAxB,CAA5B,EAA2D;AACzD,MAAA,MAAA,IAAU,IAAA,CAAK,IAAL,EAAV;AAAe,KADjB,MAEO;AACL,MAAA,MAAA,IAAU,IAAI,IAAA,CAAK,IAAL,EAAK,EAAnB;AAAmB;;AAErB,WAAO;AACL,MAAA,oBAAA,EAAsB,wBAAA,CAAyB,IAAzB,CADjB;AAEL,MAAA;AAFK,KAAP;AAEE,GATC,EAYL;AACE,IAAA,oBAAA,EAAsB,IADxB;AAEE,IAAA,MAAA,EAAQ;AAFV,GAZK,EAgBL,MAhBF;AAgBE;;AAgBG,SAAA,gBAAA,CAA0B,KAA1B,EAAwD;AAC7D,MAAI,KAAA,CAAM,MAAN,KAAiB,CAArB,EAAwB,OAAO,EAAP;AAExB,QAAM,WAAA,GAAmC,KAAA,CAAM,MAAN,CACtC,CAAD,IAAoC,CAAC,CAAC,CADC,CAAzC;AAGA,QAAM,cAAA,GAA2B,WAAA,CAAY,GAAZ,CAC9B,QAAD,IAAiC;AAC/B,QAAI,KAAA,CAAM,OAAN,CAAc,QAAd,CAAJ,EAA6B;AAC3B,aAAO,gBAAA,CAAiB,QAAjB,CAAP;AAAwB;;AAG1B,WAAO,QAAP;AAAO,GANsB,CAAjC;;AAWA,OAAA,MAAW,QAAX,IAAuB,cAAvB,EAAuC;AACrC,QAAI,QAAA,IAAY,OAAO,QAAP,KAAoB,QAApC,EAA8C;AAC5C,YAAM,IAAI,qBAAJ,CACJ,cADI,EAEJ,QAFI,EAGJ,0EAA0E,QAAA,IAHtE,CAAN;AAG4E;AAAA;;AAMhF,QAAM,YAAA,GAAe,cAAA,CAAe,GAAf,CAAmB,CAAA,IAAK,CAAA,CAAE,IAAF,EAAxB,CAArB;AAGA,QAAM,mBAAA,GAAsB,YAAA,CAAa,MAAb,CAAoB,CAAA,IAAK,CAAA,KAAM,EAA/B,CAA5B;AAEA,SAAO,qBAAA,CAAsB,mBAAtB,CAAP;AAA6B;;AAGxB,MAAA,qBAAA,SAAoC,SAApC,CAA8C;AAInD,EAAA,WAAA,CAAY,IAAZ,EAAiC,QAAjC,EAAgD,OAAhD,EAAiE;AAC/D,UAAM,OAAN;;AAJF,IAAA,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA;;AACA,IAAA,aAAA,CAAA,IAAA,EAAA,UAAA,CAAA;;AAKE,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,IAAL,GAAY,uBAAZ;AAAY;;AATqC","sourcesContent":["import { SQLFragment, TruthySQLFragment } from '../generic/sql-fragment';\n\nfunction doesNotWantLeadingSpace(str: string): boolean {\n  return /^[;,)]/.test(str);\n}\nfunction doesNotWantTrailingSpace(str: string): boolean {\n  return /\\($/.test(str);\n}\n\n/**\n * Joins an array of strings with a single space between them,\n * except for:\n *\n * - Strings starting with ';', ',' and ')', which do not get a leading space.\n * - Strings ending with '(', which do not get a trailing space.\n *\n * @param {string[]} parts\n * @returns {string}\n * @private\n */\nfunction singleSpaceJoinHelper(parts: string[]): string {\n  return parts.reduce(\n    ({ skipNextLeadingSpace, result }, part) => {\n      if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {\n        result += part.trim();\n      } else {\n        result += ` ${part.trim()}`;\n      }\n      return {\n        skipNextLeadingSpace: doesNotWantTrailingSpace(part),\n        result\n      };\n    },\n    {\n      skipNextLeadingSpace: true,\n      result: ''\n    }\n  ).result;\n}\n\n/**\n * Joins an array with a single space, auto trimming when needed.\n *\n * Certain elements do not get leading/trailing spaces.\n *\n * @param {SQLFragment[]} array The array to be joined. Falsy values are skipped. If an\n * element is another array, this function will be called recursively on that array.\n * Otherwise, if a non-string, non-falsy value is present, a TypeError will be thrown.\n *\n * @returns {string} The joined string.\n *\n * @private\n */\nexport function joinSQLFragments(array: SQLFragment[]): string {\n  if (array.length === 0) return '';\n\n  const truthyArray: TruthySQLFragment[] = array.filter(\n    (x): x is string | SQLFragment[] => !!x\n  );\n  const flattenedArray: string[] = truthyArray.map(\n    (fragment: TruthySQLFragment) => {\n      if (Array.isArray(fragment)) {\n        return joinSQLFragments(fragment);\n      }\n\n      return fragment;\n    }\n  );\n\n  // Ensure strings\n  for (const fragment of flattenedArray) {\n    if (fragment && typeof fragment !== 'string') {\n      throw new JoinSQLFragmentsError(\n        flattenedArray,\n        fragment,\n        `Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`\n      );\n    }\n  }\n\n  // Trim fragments\n  const trimmedArray = flattenedArray.map(x => x.trim());\n\n  // Skip full-whitespace fragments (empty after the above trim)\n  const nonEmptyStringArray = trimmedArray.filter(x => x !== '');\n\n  return singleSpaceJoinHelper(nonEmptyStringArray);\n}\n\nexport class JoinSQLFragmentsError extends TypeError {\n  args: SQLFragment[];\n  fragment: any; // iirc this error is only used when we get an invalid fragment.\n\n  constructor(args: SQLFragment[], fragment: any, message: string) {\n    super(message);\n    \n    this.args = args;\n    this.fragment = fragment;\n    this.name = 'JoinSQLFragmentsError';\n  }\n}\n"]},"metadata":{},"sourceType":"script"}