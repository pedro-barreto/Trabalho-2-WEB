{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst SequelizeErrors = require(\"../../errors\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst DataTypes = require(\"../../data-types\").snowflake;\n\nconst debug = logger.debugContext(\"connection:snowflake\");\n\nconst parserStore = require(\"../parserStore\")(\"snowflake\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"snowflake-sdk\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role\n    }, config.dialectOptions);\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n      debug(\"connection acquired\");\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const tzOffset = this.sequelize.options.timezone === \"+00:00\" ? \"Etc/UTC\" : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n\n        if (isNamedTzOffset) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n\n            });\n          });\n        } else {\n          throw Error(\"only support time zone name for snowflake!\");\n        }\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (!connection.isUp()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      connection.destroy(err => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection.isUp();\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\snowflake\\connection-manager.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').snowflake;\nconst debug = logger.debugContext('connection:snowflake');\nconst parserStore = require('../parserStore')('snowflake');\n\n/**\n * Snowflake Connection Manager\n *\n * Get connections, validate and disconnect them.\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('snowflake-sdk');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with a snowflake database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role,\n      /*\n      flags: '-FOUND_ROWS',\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      */\n      ...config.dialectOptions\n    };\n\n    try {\n\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n\n      debug('connection acquired');\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        // default value is '+00:00', put a quick workaround for it.\n        const tzOffset = this.sequelize.options.timezone === '+00:00' ? 'Etc/UTC' : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if ( isNamedTzOffset ) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error('only support time zone name for snowflake!');\n        }\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (!connection.isUp()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      connection.destroy(err => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection.isUp();\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}