{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst validator = _.cloneDeep(require(\"validator\"));\n\nconst moment = require(\"moment\");\n\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n    return this;\n  },\n\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n\n  isUrl(str) {\n    return this.isURL(str);\n  },\n\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n\n  regex(str, pattern, modifiers) {\n    str += \"\";\n\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== \"RegExp\") {\n      pattern = new RegExp(pattern, modifiers);\n    }\n\n    return str.match(pattern);\n  },\n\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n\n  isDecimal(str) {\n    return str !== \"\" && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n\n};\nexports.extensions = extensions;\n\nvalidator.isImmutable = function (value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\n\nvalidator.notNull = function (val) {\n  return val !== null && val !== void 0;\n};\n\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\n\nvalidator.isNull = validator.isEmpty;\n\nvalidator.isDate = function (dateString) {\n  const parsed = Date.parse(dateString);\n\n  if (isNaN(parsed)) {\n    return false;\n  }\n\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\n\nexports.validator = validator;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\utils\\validator-extras.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst validator = _.cloneDeep(require('validator'));\nconst moment = require('moment');\n\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += '';\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\n\n// instance based validators\nvalidator.isImmutable = function(value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\n\n// extra validators\nvalidator.notNull = function(val) {\n  return val !== null && val !== undefined;\n};\n\n// https://github.com/chriso/validator.js/blob/6.2.0/validator.js\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\n\n// map isNull to isEmpty\n// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125\nvalidator.isNull = validator.isEmpty;\n\n// isDate removed in 7.0.0\n// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9\nvalidator.isDate = function(dateString) {\n  // avoid http://momentjs.com/guides/#/warnings/js-date/\n  // by doing a preliminary check on `dateString`\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    // fail if we can't parse it\n    return false;\n  }\n  // otherwise convert to ISO 8601 as moment prefers\n  // http://momentjs.com/docs/#/parsing/string/\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\n\nexports.validator = validator;\n"]},"metadata":{},"sourceType":"script"}