{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return \"\";\n  }\n\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n\n  if (bound === \"infinity\") {\n    return Infinity;\n  }\n\n  if (bound === \"-infinity\") {\n    return -Infinity;\n  }\n\n  return parseType(bound);\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n  if (!Array.isArray(data)) throw new Error(\"range must be an array\");\n  if (!data.length) return \"empty\";\n  if (data.length !== 2) throw new Error(\"range array length must be 0 (empty) or 2 (lower and upper bounds)\");\n\n  if (Object.prototype.hasOwnProperty.call(data, \"inclusive\")) {\n    if (data.inclusive === false) data.inclusive = [false, false];else if (!data.inclusive) data.inclusive = [true, false];else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, \"value\")) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return `${(data.inclusive[0] ? \"[\" : \"(\") + lowerBound},${upperBound}${data.inclusive[1] ? \"]\" : \")\"}`;\n}\n\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n\n  if (value === \"empty\") {\n    return [];\n  }\n\n  let result = value.substring(1, value.length - 1).split(\",\", 2);\n  if (result.length !== 2) return value;\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === \"[\" : value[value.length - 1] === \"]\"\n    };\n  });\n  return result;\n}\n\nexports.parse = parse;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\postgres\\range.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === 'infinity') {\n    return Infinity;\n  }\n  if (bound === '-infinity') {\n    return -Infinity;\n  }\n  return parseType(bound);\n\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!Array.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    return [];\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'\n    };\n  });\n\n  return result;\n}\nexports.parse = parse;\n"]},"metadata":{},"sourceType":"script"}