{"ast":null,"code":"\"use strict\";\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(`Naming collision between attribute '${association.as}' and association '${association.as}' on model ${association.source.name}. To remedy this, change either foreignKey or as in your association definition`);\n  }\n}\n\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    const primaryKeys = Object.keys(source.primaryKeys).map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\n\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function () {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\n\nexports.mixinMethods = mixinMethods;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\associations\\helpers.js"],"names":[],"mappings":";;AAEA,SAAA,oBAAA,CAA8B,WAA9B,EAA2C;AACzC,MAAI,MAAA,CAAO,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,WAAA,CAAY,MAAZ,CAAmB,aAAxD,EAAuE,WAAA,CAAY,EAAnF,CAAJ,EAA4F;AAC1F,UAAM,IAAI,KAAJ,CACJ,uCAAuC,WAAA,CAAY,EAAA,sBAC9B,WAAA,CAAY,EAAA,cAAgB,WAAA,CAAY,MAAZ,CAAmB,IAAA,iFAFhE,CAAN;AAEsE;AAAA;;AAK1E,OAAA,CAAQ,oBAAR,GAA+B,oBAA/B;;AAEA,SAAA,wBAAA,CAAkC,YAAlC,EAAgD,MAAhD,EAAwD,MAAxD,EAAgE,OAAhE,EAAyE,GAAzE,EAA8E;AAI5E,MAAI,OAAA,CAAQ,oBAAR,IAAgC,OAAA,CAAQ,QAAxC,IAAoD,OAAA,CAAQ,QAAhE,EAA0E;AAExE,UAAM,WAAA,GAAc,MAAA,CAAO,IAAP,CAAY,MAAA,CAAO,WAAnB,EACjB,GADiB,CACb,mBAAA,IAAuB,MAAA,CAAO,aAAP,CAAqB,mBAArB,EAA0C,KAA1C,IAAmD,mBAD7D,CAApB;;AAGA,QAAI,WAAA,CAAY,MAAZ,KAAuB,CAAvB,IAA4B,CAAC,WAAA,CAAY,QAAZ,CAAqB,GAArB,CAAjC,EAA4D;AAC1D,MAAA,YAAA,CAAa,UAAb,GAA0B;AACxB,QAAA,KAAA,EAAO,MAAA,CAAO,YAAP,EADiB;AAExB,QAAA,GAAA,EAAK,GAAA,IAAO,WAAA,CAAY,CAAZ;AAFY,OAA1B;AAKA,MAAA,YAAA,CAAa,QAAb,GAAwB,OAAA,CAAQ,QAAhC;AACA,MAAA,YAAA,CAAa,QAAb,GAAwB,OAAA,CAAQ,QAAhC;AAAgC;AAAA;AAAA;;AAItC,OAAA,CAAQ,wBAAR,GAAmC,wBAAnC;;AAaA,SAAA,YAAA,CAAsB,WAAtB,EAAmC,GAAnC,EAAwC,OAAxC,EAAiD,OAAjD,EAA0D;AACxD,EAAA,OAAA,GAAU,OAAA,IAAW,EAArB;;AAEA,OAAA,MAAW,MAAX,IAAqB,OAArB,EAA8B;AAE5B,QAAI,CAAC,MAAA,CAAO,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,GAArC,EAA0C,WAAA,CAAY,SAAZ,CAAsB,MAAtB,CAA1C,CAAL,EAA+E;AAC7E,YAAM,UAAA,GAAa,OAAA,CAAQ,MAAR,CAAA,IAAmB,MAAtC;;AAEA,MAAA,GAAA,CAAI,WAAA,CAAY,SAAZ,CAAsB,MAAtB,CAAJ,CAAA,GAAqC,YAAW;AAC9C,eAAO,WAAA,CAAY,UAAZ,CAAA,CAAwB,IAAxB,EAA8B,GAAG,KAAA,CAAM,IAAN,CAAW,SAAX,CAAjC,CAAP;AAAmD,OADrD;AACqD;AAAA;AAAA;;AAK3D,OAAA,CAAQ,YAAR,GAAuB,YAAvB","sourcesContent":["'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\n      `Naming collision between attribute '${association.as}'` +\n      ` and association '${association.as}' on model ${association.source.name}` +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys)\n      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {object} association instance\n * @param {object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {object} aliases Mapping between model and association method names\n *\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n"]},"metadata":{},"sourceType":"script"}