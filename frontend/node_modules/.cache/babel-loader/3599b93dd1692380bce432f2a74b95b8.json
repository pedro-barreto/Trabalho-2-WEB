{"ast":null,"code":"\"use strict\";\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst AsyncQueue = require(\"./async-queue\").default;\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst DataTypes = require(\"../../data-types\").mssql;\n\nconst parserStore = require(\"../parserStore\")(\"mssql\");\n\nconst debug = logger.debugContext(\"connection:mssql\");\nconst debugTedious = logger.debugContext(\"connection:mssql:tedious\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"tedious\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: \"default\",\n        options: {\n          userName: config.username || void 0,\n          password: config.password || void 0\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener(\"end\", endHandler);\n          connection.removeListener(\"error\", errorHandler);\n          if (error) return reject(error);\n          debug(\"connection acquired\");\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"error\", errorHandler);\n          reject(new Error(\"Connection was closed by remote server\"));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"end\", endHandler);\n          reject(error);\n        };\n\n        connection.once(\"error\", errorHandler);\n        connection.once(\"end\", endHandler);\n        connection.once(\"connect\", connectHandler);\n        connection.on(\"error\", error => {\n          switch (error.code) {\n            case \"ESOCKET\":\n            case \"ECONNRESET\":\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on(\"debug\", debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case \"ESOCKET\":\n          if (error.message.includes(\"connect EHOSTUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"connect ENETUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"connect EADDRNOTAVAIL\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"getaddrinfo ENOTFOUND\")) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n\n          if (error.message.includes(\"connect ECONNREFUSED\")) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n\n          throw new sequelizeErrors.ConnectionError(error);\n\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ELOGIN\":\n          throw new sequelizeErrors.AccessDeniedError(error);\n\n        case \"EINVAL\":\n          throw new sequelizeErrors.InvalidConnectionError(error);\n\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n    return new Promise(resolve => {\n      connection.on(\"end\", resolve);\n      connection.close();\n      debug(\"connection closed\");\n    });\n  }\n\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === \"LoggedIn\");\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\mssql\\connection-manager.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst AsyncQueue = require('./async-queue').default;\nconst { logger } = require('../../utils/logger');\nconst sequelizeErrors = require('../../errors');\nconst DataTypes = require('../../data-types').mssql;\nconst parserStore = require('../parserStore')('mssql');\nconst debug = logger.debugContext('connection:mssql');\nconst debugTedious = logger.debugContext('connection:mssql:tedious');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('tedious');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: 'default',\n        options: {\n          userName: config.username || undefined,\n          password: config.password || undefined\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (\n        config.dialectOptions.options &&\n        config.dialectOptions.options.instanceName\n      ) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener('end', endHandler);\n          connection.removeListener('error', errorHandler);\n\n          if (error) return reject(error);\n\n          debug('connection acquired');\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', errorHandler);\n          reject(new Error('Connection was closed by remote server'));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('end', endHandler);\n          reject(error);\n        };\n\n        connection.once('error', errorHandler);\n        connection.once('end', endHandler);\n        connection.once('connect', connectHandler);\n\n        /*\n         * Permanently attach this event before connection is even acquired\n         * tedious sometime emits error even after connect(with error).\n         *\n         * If we dont attach this even that unexpected error event will crash node process\n         *\n         * E.g. connectTimeout is set higher than requestTimeout\n         */\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on('debug', debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case 'ESOCKET':\n          if (error.message.includes('connect EHOSTUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect ENETUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EADDRNOTAVAIL')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('getaddrinfo ENOTFOUND')) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes('connect ECONNREFUSED')) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ELOGIN':\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case 'EINVAL':\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === 'LoggedIn');\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}