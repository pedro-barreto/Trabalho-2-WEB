{"ast":null,"code":"\"use strict\";\n\nconst wkx = require(\"wkx\");\n\nconst _ = require(\"lodash\");\n\nconst momentTz = require(\"moment-timezone\");\n\nconst moment = require(\"moment\");\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://mariadb.com/kb/en/library/resultset/#field-types\";\n  BaseTypes.DATE.types.mariadb = [\"DATETIME\"];\n  BaseTypes.STRING.types.mariadb = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mariadb = [\"STRING\"];\n  BaseTypes.TEXT.types.mariadb = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mariadb = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mariadb = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mariadb = [\"INT24\"];\n  BaseTypes.INTEGER.types.mariadb = [\"LONG\"];\n  BaseTypes.BIGINT.types.mariadb = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mariadb = [\"FLOAT\"];\n  BaseTypes.TIME.types.mariadb = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mariadb = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mariadb = [\"TINY\"];\n  BaseTypes.BLOB.types.mariadb = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mariadb = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mariadb = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mariadb = [\"JSON\"];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n\n      return definition;\n    }\n\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n\n      return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n    }\n\n    static parse(value, options) {\n      value = value.string();\n\n      if (value === null) {\n        return value;\n      }\n\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n\n      return value;\n    }\n\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n\n  }\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      } else {\n        this.sqlType = this.type;\n      }\n    }\n\n    static parse(value) {\n      value = value.buffer();\n\n      if (!value || value.length === 0) {\n        return null;\n      }\n\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({\n        shortCrs: true\n      });\n    }\n\n    toSql() {\n      return this.sqlType;\n    }\n\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(\", \")})`;\n    }\n\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n\n  }\n\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\mariadb\\data-types.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst wkx = require('wkx');\nconst _ = require('lodash');\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://mariadb.com/kb/en/library/resultset/#field-types';\n\n  /**\n   * types: [buffer_type, ...]\n   *\n   * @see documentation : https://mariadb.com/kb/en/library/resultset/#field-types\n   * @see connector implementation : https://github.com/MariaDB/mariadb-connector-nodejs/blob/master/lib/const/field-type.js\n   */\n\n  BaseTypes.DATE.types.mariadb = ['DATETIME'];\n  BaseTypes.STRING.types.mariadb = ['VAR_STRING'];\n  BaseTypes.CHAR.types.mariadb = ['STRING'];\n  BaseTypes.TEXT.types.mariadb = ['BLOB'];\n  BaseTypes.TINYINT.types.mariadb = ['TINY'];\n  BaseTypes.SMALLINT.types.mariadb = ['SHORT'];\n  BaseTypes.MEDIUMINT.types.mariadb = ['INT24'];\n  BaseTypes.INTEGER.types.mariadb = ['LONG'];\n  BaseTypes.BIGINT.types.mariadb = ['LONGLONG'];\n  BaseTypes.FLOAT.types.mariadb = ['FLOAT'];\n  BaseTypes.TIME.types.mariadb = ['TIME'];\n  BaseTypes.DATEONLY.types.mariadb = ['DATE'];\n  BaseTypes.BOOLEAN.types.mariadb = ['TINY'];\n  BaseTypes.BLOB.types.mariadb = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.mariadb = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.mariadb = ['DOUBLE'];\n  BaseTypes.GEOMETRY.types.mariadb = ['GEOMETRY'];\n  BaseTypes.JSON.types.mariadb = ['JSON'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += ' UNSIGNED';\n      }\n      if (this._zerofill) {\n        definition += ' ZEROFILL';\n      }\n      return definition;\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : 'DATETIME';\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n\n      return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      }\n      else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'CHAR(36) BINARY';\n    }\n  }\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      }\n      else {\n        this.sqlType = this.type;\n      }\n    }\n    static parse(value) {\n      value = value.buffer();\n      // Empty buffer, MySQL doesn't support POINT EMPTY\n      // check, https://dev.mysql.com/worklog/task/?id=2381\n      if (!value || value.length === 0) {\n        return null;\n      }\n      // For some reason, discard the first 4 bytes\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value\n        : JSON.stringify(value);\n    }\n  }\n\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n"]},"metadata":{},"sourceType":"script"}