{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nconst util = require(\"util\");\n\nconst Op = require(\"../../operators\");\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\"CONSTRAINT_NAME as constraint_name\", \"CONSTRAINT_NAME as constraintName\", \"CONSTRAINT_SCHEMA as constraintSchema\", \"CONSTRAINT_SCHEMA as constraintCatalog\", \"TABLE_NAME as tableName\", \"TABLE_SCHEMA as tableSchema\", \"TABLE_SCHEMA as tableCatalog\", \"COLUMN_NAME as columnName\", \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\", \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\", \"REFERENCED_TABLE_NAME as referencedTableName\", \"REFERENCED_COLUMN_NAME as referencedColumnName\"].join(\",\");\nconst SNOWFLAKE_RESERVED_WORDS = \"account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with\".split(\",\");\nconst typeWithoutDefault = /* @__PURE__ */new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\n\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\"CREATE DATABASE IF NOT EXISTS\", this.quoteIdentifier(databaseName), options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`, options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`, \";\"]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n\n  versionQuery() {\n    return \"SELECT CURRENT_VERSION()\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\"CREATE TABLE IF NOT EXISTS\", table, `(${attributesClause})`, options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`, options.charset && `DEFAULT CHARSET=${options.charset}`, options.collate && `COLLATE ${options.collate}`, options.rowFormat && `ROW_FORMAT=${options.rowFormat}`, \";\"]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\", database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : \"AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\", \";\"]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: \"addColumn\",\n      tableName: table,\n      foreignKey: key\n    }), \";\"]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    var _this = this;\n\n    const query = function () {\n      for (var _len = arguments.length, subQuerys = new Array(_len), _key = 0; _key < _len; _key++) {\n        subQuerys[_key] = arguments[_key];\n      }\n\n      return Utils.joinSQLFragments([\"ALTER TABLE\", _this.quoteTable(tableName), \"ALTER COLUMN\", ...subQuerys, \";\"]);\n    };\n\n    const sql = [];\n\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET NOT NULL\"));\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP NOT NULL\"));\n      }\n\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET DEFAULT\", definition.match(/DEFAULT ([^;]+)/)[1]));\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP DEFAULT\"));\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql.push(query(\"ADD UNIQUE (\", this.quoteIdentifier(attributeName), \")\").replace(\"ALTER COLUMN\", \"\"));\n      }\n\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql.push(query(\"ADD FOREIGN KEY (\", this.quoteIdentifier(attributeName), \")\", definition).replace(\"ALTER COLUMN\", \"\"));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"TYPE\", definition));\n      }\n\n      sql.push(attrSql.join(\"\"));\n    }\n\n    return sql.join(\"\");\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"RENAME COLUMN\", attrString.join(\" to \"), \";\"]);\n  }\n\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n\n      if (attr.path) {\n        let str;\n\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          const paths = _.toPath(attr.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (attr.value) {\n          str += util.format(\" = %s\", this.escape(attr.value));\n        }\n\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = \"datetime\";\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        attr.type = \"char\";\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = \"decimal\";\n      } else if (/text/i.test(attr.type)) {\n        attr.type = \"char\";\n      }\n    }\n\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\"TRUNCATE\", this.quoteTable(tableName)]);\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return Utils.joinSQLFragments([\"DELETE FROM\", table, \"WHERE\", primaryKeys, \"IN (SELECT\", primaryKeysSelection, \"FROM\", table, whereClause, limit, \")\", \";\"]);\n    }\n\n    return Utils.joinSQLFragments([\"DELETE FROM\", table, whereClause, \";\"]);\n  }\n\n  showIndexesQuery() {\n    return \"SELECT '' FROM DUAL\";\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\", \"CONSTRAINT_NAME AS constraintName,\", \"CONSTRAINT_SCHEMA AS constraintSchema,\", \"CONSTRAINT_TYPE AS constraintType,\", \"TABLE_NAME AS tableName,\", \"TABLE_SCHEMA AS tableSchema\", \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\", `WHERE table_name='${tableName}'`, constraintName && `AND constraint_name = '${constraintName}'`, schemaName && `AND TABLE_SCHEMA = '${schemaName}'`, \";\"]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return Utils.joinSQLFragments([\"DROP INDEX\", this.quoteIdentifier(indexName), \"ON\", this.quoteTable(tableName), \";\"]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n\n    if (attribute.autoIncrement) {\n      template += \" AUTOINCREMENT\";\n    }\n\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    return hasJsonFunction;\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n\n    return dataType;\n  }\n\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`, `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\", \";\"]);\n  }\n\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\", \"WHERE (\", [`REFERENCED_TABLE_NAME = ${quotedTableName}`, table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`, `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`], \") OR (\", [`TABLE_NAME = ${quotedTableName}`, table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`, `AND COLUMN_NAME = ${quotedColumnName}`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\"], \")\"]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP FOREIGN KEY\", this.quoteIdentifier(foreignKey), \";\"]);\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = [];\n\n    if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {\n      fragment = fragment.concat([\" LIMIT \", this.escape(options.limit), \" OFFSET \", this.escape(options.offset)]);\n    } else if (options.limit !== null && options.limit !== void 0) {\n      fragment = [\" LIMIT \", this.escape(options.limit)];\n    }\n\n    return fragment.join(\"\");\n  }\n\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n\n    return rawIdentifier;\n  }\n\n}\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\n\nmodule.exports = SnowflakeQueryGenerator;","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\snowflake\\query-generator.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAM,CAAA,GAAI,OAAA,CAAQ,QAAR,CAAV;;AACA,MAAM,KAAA,GAAQ,OAAA,CAAQ,aAAR,CAAd;;AACA,MAAM,sBAAA,GAAyB,OAAA,CAAQ,6BAAR,CAA/B;;AACA,MAAM,IAAA,GAAO,OAAA,CAAQ,MAAR,CAAb;;AACA,MAAM,EAAA,GAAK,OAAA,CAAQ,iBAAR,CAAX;;AAGA,MAAM,mBAAA,GAAsB,wDAA5B;AACA,MAAM,mBAAA,GAAsB,oCAA5B;AACA,MAAM,mBAAA,GAAsB,4DAA5B;AACA,MAAM,kBAAA,GAAqB,CACzB,oCADyB,EAEzB,mCAFyB,EAGzB,uCAHyB,EAIzB,wCAJyB,EAKzB,yBALyB,EAMzB,6BANyB,EAOzB,8BAPyB,EAQzB,2BARyB,EASzB,kDATyB,EAUzB,mDAVyB,EAWzB,8CAXyB,EAYzB,gDAZyB,EAazB,IAbyB,CAapB,GAboB,CAA3B;AAqBA,MAAM,wBAAA,GAA2B,4mBAA4mB,KAA5mB,CAAknB,GAAlnB,CAAjC;AAEA,MAAM,kBAAA,GAAqB,eAAA,IAAI,GAAJ,CAAQ,CAAC,MAAD,EAAS,MAAT,EAAiB,UAAjB,EAA6B,MAA7B,CAAR,CAA3B;;AAEA,MAAA,uBAAA,SAAsC,sBAAtC,CAA6D;AAC3D,EAAA,WAAA,CAAY,OAAZ,EAAqB;AACnB,UAAM,OAAN;AAEA,SAAK,WAAL,GAAmB,aAAA,CAAA,cAAA,CAAA,EAAA,EACd,KAAK,WADS,CAAA,EAAA;AAAA,OAEhB,EAAA,CAAG,MAFa,GAEJ,QAFI;AAEJ,OACZ,EAAA,CAAG,SADS,GACG;AAHC,KAAA,CAAnB;AAGkB;;AAIpB,EAAA,mBAAA,CAAoB,YAApB,EAAkC,OAAlC,EAA2C;AACzC,IAAA,OAAA,GAAU,cAAA,CAAA;AACR,MAAA,OAAA,EAAS,IADD;AAER,MAAA,OAAA,EAAS;AAFD,KAAA,EAGL,OAHK,CAAV;AAMA,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,+BAD4B,EAE5B,KAAK,eAAL,CAAqB,YAArB,CAF4B,EAG5B,OAAA,CAAQ,OAAR,IAAmB,yBAAyB,KAAK,MAAL,CAAY,OAAA,CAAQ,OAApB,CAAoB,EAHpC,EAI5B,OAAA,CAAQ,OAAR,IAAmB,mBAAmB,KAAK,MAAL,CAAY,OAAA,CAAQ,OAApB,CAAoB,EAJ9B,EAK5B,GAL4B,CAAvB,CAAP;AAKE;;AAIJ,EAAA,iBAAA,CAAkB,YAAlB,EAAgC;AAC9B,WAAO,2BAA2B,KAAK,eAAL,CAAqB,YAArB,CAAqB,GAAvD;AAAuD;;AAGzD,EAAA,YAAA,GAAe;AACb,WAAO,aAAP;AAAO;;AAGT,EAAA,gBAAA,GAAmB;AACjB,WAAO,aAAP;AAAO;;AAGT,EAAA,YAAA,GAAe;AACb,WAAO,0BAAP;AAAO;;AAGT,EAAA,gBAAA,CAAiB,SAAjB,EAA4B,UAA5B,EAAwC,OAAxC,EAAiD;AAC/C,IAAA,OAAA,GAAU,cAAA,CAAA;AACR,MAAA,OAAA,EAAS,IADD;AAER,MAAA,SAAA,EAAW;AAFH,KAAA,EAGL,OAHK,CAAV;AAMA,UAAM,WAAA,GAAc,EAApB;AACA,UAAM,WAAA,GAAc,EAApB;AACA,UAAM,OAAA,GAAU,EAAhB;;AAEA,SAAA,MAAW,IAAX,IAAmB,UAAnB,EAA+B;AAC7B,UAAI,CAAC,MAAA,CAAO,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,UAArC,EAAiD,IAAjD,CAAL,EAA6D;AAC7D,YAAM,QAAA,GAAW,UAAA,CAAW,IAAX,CAAjB;AACA,UAAI,KAAJ;;AAEA,UAAI,QAAA,CAAS,QAAT,CAAkB,aAAlB,CAAJ,EAAsC;AACpC,QAAA,WAAA,CAAY,IAAZ,CAAiB,IAAjB;;AAEA,YAAI,QAAA,CAAS,QAAT,CAAkB,YAAlB,CAAJ,EAAqC;AACnC,UAAA,KAAA,GAAQ,QAAA,CAAS,KAAT,CAAe,uBAAf,CAAR;AACA,UAAA,OAAA,CAAQ,IAAR,CAAa,GAAG,KAAK,eAAL,CAAqB,IAArB,CAAqB,IAAS,KAAA,CAAM,CAAN,CAAA,CAAS,OAAT,CAAiB,aAAjB,EAAgC,EAAhC,CAAgC,EAA9E;AACA,UAAA,WAAA,CAAY,IAAZ,CAAA,GAAoB,KAAA,CAAM,CAAN,CAApB;AAA0B,SAH5B,MAIO;AACL,UAAA,OAAA,CAAQ,IAAR,CAAa,GAAG,KAAK,eAAL,CAAqB,IAArB,CAAqB,IAAS,QAAA,CAAS,OAAT,CAAiB,aAAjB,EAAgC,EAAhC,CAAgC,EAA9E;AAA8E;AAAA,OARlF,MAQkF,IAEvE,QAAA,CAAS,QAAT,CAAkB,YAAlB,CAFuE,EAEtC;AAC1C,QAAA,KAAA,GAAQ,QAAA,CAAS,KAAT,CAAe,uBAAf,CAAR;AACA,QAAA,OAAA,CAAQ,IAAR,CAAa,GAAG,KAAK,eAAL,CAAqB,IAArB,CAAqB,IAAS,KAAA,CAAM,CAAN,CAAM,EAApD;AACA,QAAA,WAAA,CAAY,IAAZ,CAAA,GAAoB,KAAA,CAAM,CAAN,CAApB;AAA0B,OALsD,MAM3E;AACL,QAAA,OAAA,CAAQ,IAAR,CAAa,GAAG,KAAK,eAAL,CAAqB,IAArB,CAAqB,IAAS,QAAA,EAA9C;AAA8C;AAAA;;AAIlD,UAAM,KAAA,GAAQ,KAAK,UAAL,CAAgB,SAAhB,CAAd;AACA,QAAI,gBAAA,GAAmB,OAAA,CAAQ,IAAR,CAAa,IAAb,CAAvB;AACA,UAAM,QAAA,GAAW,WAAA,CAAY,GAAZ,CAAgB,EAAA,IAAM,KAAK,eAAL,CAAqB,EAArB,CAAtB,EAAgD,IAAhD,CAAqD,IAArD,CAAjB;;AAEA,QAAI,OAAA,CAAQ,UAAZ,EAAwB;AACtB,MAAA,CAAA,CAAE,IAAF,CAAO,OAAA,CAAQ,UAAf,EAA2B,CAAC,OAAD,EAAU,SAAV,KAAwB;AACjD,YAAI,OAAA,CAAQ,WAAZ,EAAyB;AACvB,cAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACjC,YAAA,SAAA,GAAY,QAAQ,SAAA,IAAa,OAAA,CAAQ,MAAR,CAAe,IAAf,CAAoB,GAApB,CAAoB,EAArD;AAAqD;;AAEvD,UAAA,gBAAA,IAAoB,YAAY,KAAK,eAAL,CAAqB,SAArB,CAAqB,KAAe,OAAA,CAAQ,MAAR,CAAe,GAAf,CAAmB,KAAA,IAAS,KAAK,eAAL,CAAqB,KAArB,CAA5B,EAAyD,IAAzD,CAA8D,IAA9D,CAA8D,GAAlI;AAAkI;AAAA,OALtI;AAKsI;;AAKxI,QAAI,QAAA,CAAS,MAAT,GAAkB,CAAtB,EAAyB;AACvB,MAAA,gBAAA,IAAoB,kBAAkB,QAAA,GAAtC;AAAsC;;AAGxC,SAAA,MAAW,IAAX,IAAmB,WAAnB,EAAgC;AAC9B,UAAI,MAAA,CAAO,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,WAArC,EAAkD,IAAlD,CAAJ,EAA6D;AAC3D,QAAA,gBAAA,IAAoB,kBAAkB,KAAK,eAAL,CAAqB,IAArB,CAAqB,KAAU,WAAA,CAAY,IAAZ,CAAY,EAAjF;AAAiF;AAAA;;AAIrF,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,4BAD4B,EAE5B,KAF4B,EAG5B,IAAI,gBAAA,GAHwB,EAI5B,OAAA,CAAQ,OAAR,IAAmB,OAAO,OAAA,CAAQ,OAAf,KAA2B,QAA9C,IAA0D,WAAW,KAAK,MAAL,CAAY,OAAA,CAAQ,OAApB,CAAoB,EAJ7D,EAK5B,OAAA,CAAQ,OAAR,IAAmB,mBAAmB,OAAA,CAAQ,OAAA,EALlB,EAM5B,OAAA,CAAQ,OAAR,IAAmB,WAAW,OAAA,CAAQ,OAAA,EANV,EAO5B,OAAA,CAAQ,SAAR,IAAqB,cAAc,OAAA,CAAQ,SAAA,EAPf,EAQ5B,GAR4B,CAAvB,CAAP;AAQE;;AAIJ,EAAA,kBAAA,CAAmB,SAAnB,EAA8B,MAA9B,EAAsC,eAAtC,EAAuD;AACrD,UAAM,KAAA,GAAQ,KAAK,UAAL,CACZ,KAAK,SAAL,CAAe;AACb,MAAA,SADa;AAEb,MAAA,OAAA,EAAS,MAFI;AAGb,MAAA,gBAAA,EAAkB;AAHL,KAAf,CADY,CAAd;AAQA,WAAO,0BAA0B,KAAA,GAAjC;AAAiC;;AAGnC,EAAA,eAAA,CAAgB,QAAhB,EAA0B;AACxB,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,kFAD4B,EAE5B,QAAA,GAAW,sBAAsB,KAAK,MAAL,CAAY,QAAZ,CAAY,EAA7C,GAA2D,8EAF/B,EAG5B,GAH4B,CAAvB,CAAP;AAGE;;AAIJ,EAAA,cAAA,CAAe,KAAf,EAAsB,GAAtB,EAA2B,QAA3B,EAAqC;AACnC,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,aAD4B,EAE5B,KAAK,UAAL,CAAgB,KAAhB,CAF4B,EAG5B,KAH4B,EAI5B,KAAK,eAAL,CAAqB,GAArB,CAJ4B,EAK5B,KAAK,cAAL,CAAoB,QAApB,EAA8B;AAC5B,MAAA,OAAA,EAAS,WADmB;AAE5B,MAAA,SAAA,EAAW,KAFiB;AAG5B,MAAA,UAAA,EAAY;AAHgB,KAA9B,CAL4B,EAU5B,GAV4B,CAAvB,CAAP;AAUE;;AAIJ,EAAA,iBAAA,CAAkB,SAAlB,EAA6B,aAA7B,EAA4C;AAC1C,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,aAD4B,EAE5B,KAAK,UAAL,CAAgB,SAAhB,CAF4B,EAG5B,MAH4B,EAI5B,KAAK,eAAL,CAAqB,aAArB,CAJ4B,EAK5B,GAL4B,CAAvB,CAAP;AAKE;;AAIJ,EAAA,iBAAA,CAAkB,SAAlB,EAA6B,UAA7B,EAAyC;AAAA;;AACvC,UAAM,KAAA,GAAQ;AAAA,wCAAI,SAAJ;AAAI,QAAA,SAAJ;AAAA;;AAAA,aAAkB,KAAA,CAAM,gBAAN,CAAuB,CACrD,aADqD,EAErD,KAAA,CAAK,UAAL,CAAgB,SAAhB,CAFqD,EAGrD,cAHqD,EAIrD,GAAG,SAJkD,EAKrD,GALqD,CAAvB,CAAlB;AAAA,KAAd;;AAOA,UAAM,GAAA,GAAM,EAAZ;;AACA,SAAA,MAAW,aAAX,IAA4B,UAA5B,EAAwC;AACtC,UAAI,UAAA,GAAa,KAAK,eAAL,CAAqB,SAArB,EAAgC,aAAhC,EAA+C,UAAA,CAAW,aAAX,CAA/C,CAAjB;AACA,YAAM,OAAA,GAAU,EAAhB;;AAEA,UAAI,UAAA,CAAW,QAAX,CAAoB,UAApB,CAAJ,EAAqC;AACnC,QAAA,OAAA,CAAQ,IAAR,CAAa,KAAA,CAAM,KAAK,eAAL,CAAqB,aAArB,CAAN,EAA2C,cAA3C,CAAb;AAEA,QAAA,UAAA,GAAa,UAAA,CAAW,OAAX,CAAmB,UAAnB,EAA+B,EAA/B,EAAmC,IAAnC,EAAb;AAAgD,OAHlD,MAGkD,IACvC,CAAC,UAAA,CAAW,QAAX,CAAoB,YAApB,CADsC,EACH;AAC7C,QAAA,OAAA,CAAQ,IAAR,CAAa,KAAA,CAAM,KAAK,eAAL,CAAqB,aAArB,CAAN,EAA2C,eAA3C,CAAb;AAAwD;;AAG1D,UAAI,UAAA,CAAW,QAAX,CAAoB,SAApB,CAAJ,EAAoC;AAClC,QAAA,OAAA,CAAQ,IAAR,CAAa,KAAA,CAAM,KAAK,eAAL,CAAqB,aAArB,CAAN,EAA2C,aAA3C,EAA0D,UAAA,CAAW,KAAX,CAAiB,iBAAjB,EAAoC,CAApC,CAA1D,CAAb;AAEA,QAAA,UAAA,GAAa,UAAA,CAAW,OAAX,CAAmB,gBAAnB,EAAqC,EAArC,EAAyC,IAAzC,EAAb;AAAsD,OAHxD,MAGwD,IAC7C,CAAC,UAAA,CAAW,QAAX,CAAoB,YAApB,CAD4C,EACT;AAC7C,QAAA,OAAA,CAAQ,IAAR,CAAa,KAAA,CAAM,KAAK,eAAL,CAAqB,aAArB,CAAN,EAA2C,cAA3C,CAAb;AAAwD;;AAG1D,UAAI,UAAA,CAAW,KAAX,CAAiB,WAAjB,CAAJ,EAAmC;AACjC,QAAA,UAAA,GAAa,UAAA,CAAW,OAAX,CAAmB,WAAnB,EAAgC,EAAhC,CAAb;AACA,QAAA,OAAA,CAAQ,IAAR,CAAa,KAAA,CAAM,cAAN,EAAsB,KAAK,eAAL,CAAqB,aAArB,CAAtB,EAA2D,GAA3D,CAAA,CAAgE,OAAhE,CAAwE,cAAxE,EAAwF,EAAxF,CAAb;AAAqG;;AAGvG,UAAI,UAAA,CAAW,QAAX,CAAoB,YAApB,CAAJ,EAAuC;AACrC,QAAA,UAAA,GAAa,UAAA,CAAW,OAAX,CAAmB,mBAAnB,EAAwC,EAAxC,CAAb;AACA,QAAA,OAAA,CAAQ,IAAR,CAAa,KAAA,CAAM,mBAAN,EAA2B,KAAK,eAAL,CAAqB,aAArB,CAA3B,EAAgE,GAAhE,EAAqE,UAArE,CAAA,CAAiF,OAAjF,CAAyF,cAAzF,EAAyG,EAAzG,CAAb;AAAsH,OAFxH,MAGO;AACL,QAAA,OAAA,CAAQ,IAAR,CAAa,KAAA,CAAM,KAAK,eAAL,CAAqB,aAArB,CAAN,EAA2C,MAA3C,EAAmD,UAAnD,CAAb;AAAgE;;AAGlE,MAAA,GAAA,CAAI,IAAJ,CAAS,OAAA,CAAQ,IAAR,CAAa,EAAb,CAAT;AAAsB;;AAGxB,WAAO,GAAA,CAAI,IAAJ,CAAS,EAAT,CAAP;AAAgB;;AAGlB,EAAA,iBAAA,CAAkB,SAAlB,EAA6B,UAA7B,EAAyC,UAAzC,EAAqD;AACnD,UAAM,UAAA,GAAa,EAAnB;;AAEA,SAAA,MAAW,QAAX,IAAuB,UAAvB,EAAmC;AACjC,YAAM,UAAA,GAAa,UAAA,CAAW,QAAX,CAAnB;AACA,MAAA,UAAA,CAAW,IAAX,CAAgB,IAAI,UAAA,MAAgB,QAAA,KAAa,UAAA,EAAjD;AAAiD;;AAGnD,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,aAD4B,EAE5B,KAAK,UAAL,CAAgB,SAAhB,CAF4B,EAG5B,eAH4B,EAI5B,UAAA,CAAW,IAAX,CAAgB,MAAhB,CAJ4B,EAK5B,GAL4B,CAAvB,CAAP;AAKE;;AAIJ,EAAA,qBAAA,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC,OAAvC,EAAgD,OAAhD,EAAyD,OAAzD,EAAkE;AAChE,QAAI,IAAA,YAAgB,KAAA,CAAM,IAA1B,EAAgC;AAE9B,UAAI,IAAA,CAAK,UAAT,EAAqB;AACnB,cAAM,UAAA,GAAa,KAAK,oBAAL,CAA0B,IAAA,CAAK,UAA/B,EAA2C,GAA3C,CAA+C,SAAA,IAChE,GAAG,KAAK,uBAAL,CAA6B,SAAA,CAAU,IAAV,CAAe,CAAf,CAA7B,EAAgD,CAAA,CAAE,IAAF,CAAO,SAAA,CAAU,IAAjB,CAAhD,CAAiE,OAAa,SAAA,CAAU,KAAA,GAD1E,CAAnB;AAIA,eAAO,UAAA,CAAW,IAAX,CAAgB,OAAhB,CAAP;AAAuB;;AAEzB,UAAI,IAAA,CAAK,IAAT,EAAe;AACb,YAAI,GAAJ;;AAGA,YAAI,KAAK,wBAAL,CAA8B,IAAA,CAAK,IAAnC,CAAJ,EAA8C;AAC5C,UAAA,GAAA,GAAM,IAAA,CAAK,IAAX;AAAW,SADb,MAEO;AAEL,gBAAM,KAAA,GAAQ,CAAA,CAAE,MAAF,CAAS,IAAA,CAAK,IAAd,CAAd;;AACA,gBAAM,MAAA,GAAS,KAAA,CAAM,KAAN,EAAf;AACA,UAAA,GAAA,GAAM,KAAK,uBAAL,CAA6B,MAA7B,EAAqC,KAArC,CAAN;AAA2C;;AAG7C,YAAI,IAAA,CAAK,KAAT,EAAgB;AACd,UAAA,GAAA,IAAO,IAAA,CAAK,MAAL,CAAY,OAAZ,EAAqB,KAAK,MAAL,CAAY,IAAA,CAAK,KAAjB,CAArB,CAAP;AAA6C;;AAG/C,eAAO,GAAP;AAAO;AAAA,KA1BX,MA0BW,IAEA,IAAA,YAAgB,KAAA,CAAM,IAFtB,EAE4B;AACrC,UAAI,aAAa,IAAb,CAAkB,IAAA,CAAK,IAAvB,CAAJ,EAAkC;AAChC,QAAA,IAAA,CAAK,IAAL,GAAY,UAAZ;AAAY,OADd,MACc,IACH,IAAA,CAAK,IAAL,IAAa,WAAW,IAAX,CAAgB,IAAA,CAAK,IAArB,CADV,EACsC;AAElD,QAAA,IAAA,CAAK,IAAL,GAAY,MAAZ;AAAY,OAHA,MAGA,IACH,oBAAoB,IAApB,CAAyB,IAAA,CAAK,IAA9B,KAAuC,WAAW,IAAX,CAAgB,IAAA,CAAK,IAArB,CAAvC,IAAqE,WAAW,IAAX,CAAgB,IAAA,CAAK,IAArB,CADlE,EAC8F;AAC1G,QAAA,IAAA,CAAK,IAAL,GAAY,SAAZ;AAAY,OAFA,MAEA,IACH,QAAQ,IAAR,CAAa,IAAA,CAAK,IAAlB,CADG,EACsB;AAClC,QAAA,IAAA,CAAK,IAAL,GAAY,MAAZ;AAAY;AAAA;;AAIhB,WAAO,MAAM,qBAAN,CAA4B,IAA5B,EAAkC,SAAlC,EAA6C,OAA7C,EAAsD,OAAtD,EAA+D,OAA/D,CAAP;AAAsE;;AAGxE,EAAA,kBAAA,CAAmB,SAAnB,EAA8B;AAC5B,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,UAD4B,EAE5B,KAAK,UAAL,CAAgB,SAAhB,CAF4B,CAAvB,CAAP;AAEkB;;AAIpB,EAAA,WAAA,CAAY,SAAZ,EAAuB,KAAvB,EAAmD;AAAA,QAArB,OAAqB,uEAAX,EAAW;AAAA,QAAP,KAAO;AACjD,UAAM,KAAA,GAAQ,KAAK,UAAL,CAAgB,SAAhB,CAAd;AACA,QAAI,WAAA,GAAc,KAAK,kBAAL,CAAwB,KAAxB,EAA+B,IAA/B,EAAqC,KAArC,EAA4C,OAA5C,CAAlB;AACA,UAAM,KAAA,GAAQ,OAAA,CAAQ,KAAR,IAAiB,UAAU,KAAK,MAAL,CAAY,OAAA,CAAQ,KAApB,CAAoB,EAA7D;AACA,QAAI,WAAA,GAAc,EAAlB;AACA,QAAI,oBAAA,GAAuB,EAA3B;;AAEA,QAAI,WAAJ,EAAiB;AACf,MAAA,WAAA,GAAc,SAAS,WAAA,EAAvB;AAAuB;;AAGzB,QAAI,KAAJ,EAAW;AACT,UAAI,CAAC,KAAL,EAAY;AACV,cAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AAAgB;;AAGlB,YAAM,GAAA,GAAM,MAAA,CAAO,MAAP,CAAc,KAAA,CAAM,WAApB,EAAiC,GAAjC,CAAqC,EAAA,IAAM,KAAK,eAAL,CAAqB,EAAA,CAAG,KAAxB,CAA3C,EAA2E,IAA3E,CAAgF,GAAhF,CAAZ;AAEA,MAAA,WAAA,GAAc,KAAA,CAAM,oBAAN,CAA2B,MAA3B,GAAoC,CAApC,GAAwC,IAAI,GAAA,GAA5C,GAAqD,GAAnE;AACA,MAAA,oBAAA,GAAuB,GAAvB;AAEA,aAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,aAD4B,EAE5B,KAF4B,EAG5B,OAH4B,EAI5B,WAJ4B,EAK5B,YAL4B,EAM5B,oBAN4B,EAO5B,MAP4B,EAQ5B,KAR4B,EAS5B,WAT4B,EAU5B,KAV4B,EAW5B,GAX4B,EAY5B,GAZ4B,CAAvB,CAAP;AAYE;;AAGJ,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,aAD4B,EAE5B,KAF4B,EAG5B,WAH4B,EAI5B,GAJ4B,CAAvB,CAAP;AAIE;;AAIJ,EAAA,gBAAA,GAAmB;AACjB,WAAO,qBAAP;AAAO;;AAGT,EAAA,oBAAA,CAAqB,KAArB,EAA4B,cAA5B,EAA4C;AAC1C,UAAM,SAAA,GAAY,KAAA,CAAM,SAAN,IAAmB,KAArC;AACA,UAAM,UAAA,GAAa,KAAA,CAAM,MAAzB;AAEA,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,iDAD4B,EAE5B,oCAF4B,EAG5B,wCAH4B,EAI5B,oCAJ4B,EAK5B,0BAL4B,EAM5B,6BAN4B,EAO5B,2CAP4B,EAQ5B,qBAAqB,SAAA,GARO,EAS5B,cAAA,IAAkB,0BAA0B,cAAA,GAThB,EAU5B,UAAA,IAAc,uBAAuB,UAAA,GAVT,EAW5B,GAX4B,CAAvB,CAAP;AAWE;;AAIJ,EAAA,gBAAA,CAAiB,SAAjB,EAA4B,qBAA5B,EAAmD;AACjD,QAAI,SAAA,GAAY,qBAAhB;;AAEA,QAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACjC,MAAA,SAAA,GAAY,KAAA,CAAM,UAAN,CAAiB,GAAG,SAAA,IAAa,qBAAA,CAAsB,IAAtB,CAA2B,GAA3B,CAA2B,EAA5D,CAAZ;AAAwE;;AAG1E,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,YAD4B,EAE5B,KAAK,eAAL,CAAqB,SAArB,CAF4B,EAG5B,IAH4B,EAI5B,KAAK,UAAL,CAAgB,SAAhB,CAJ4B,EAK5B,GAL4B,CAAvB,CAAP;AAKE;;AAIJ,EAAA,cAAA,CAAe,SAAf,EAA0B,OAA1B,EAAmC;AACjC,QAAI,CAAC,CAAA,CAAE,aAAF,CAAgB,SAAhB,CAAL,EAAiC;AAC/B,MAAA,SAAA,GAAY;AACV,QAAA,IAAA,EAAM;AADI,OAAZ;AACQ;;AAIV,UAAM,eAAA,GAAkB,SAAA,CAAU,IAAV,CAAe,QAAf,CAAwB;AAAE,MAAA,MAAA,EAAQ,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB;AAAV,KAAxB,CAAxB;AACA,QAAI,QAAA,GAAW,eAAf;;AAEA,QAAI,SAAA,CAAU,SAAV,KAAwB,KAA5B,EAAmC;AACjC,MAAA,QAAA,IAAY,WAAZ;AAAY;;AAGd,QAAI,SAAA,CAAU,aAAd,EAA6B;AAC3B,MAAA,QAAA,IAAY,gBAAZ;AAAY;;AAId,QAAI,CAAC,kBAAA,CAAmB,GAAnB,CAAuB,eAAvB,CAAD,IACC,SAAA,CAAU,IAAV,CAAe,OAAf,KAA2B,IAD5B,IAEC,KAAA,CAAM,qBAAN,CAA4B,SAAA,CAAU,YAAtC,CAFL,EAE0D;AACxD,MAAA,QAAA,IAAY,YAAY,KAAK,MAAL,CAAY,SAAA,CAAU,YAAtB,CAAsB,EAA9C;AAA8C;;AAGhD,QAAI,SAAA,CAAU,MAAV,KAAqB,IAAzB,EAA+B;AAC7B,MAAA,QAAA,IAAY,SAAZ;AAAY;;AAGd,QAAI,SAAA,CAAU,UAAd,EAA0B;AACxB,MAAA,QAAA,IAAY,cAAZ;AAAY;;AAGd,QAAI,SAAA,CAAU,OAAd,EAAuB;AACrB,MAAA,QAAA,IAAY,YAAY,KAAK,MAAL,CAAY,SAAA,CAAU,OAAtB,CAAsB,EAA9C;AAA8C;;AAGhD,QAAI,SAAA,CAAU,KAAd,EAAqB;AACnB,MAAA,QAAA,IAAY,QAAZ;AAAY;;AAEd,QAAI,SAAA,CAAU,KAAd,EAAqB;AACnB,MAAA,QAAA,IAAY,UAAU,KAAK,eAAL,CAAqB,SAAA,CAAU,KAA/B,CAA+B,EAArD;AAAqD;;AAGvD,QAAI,SAAA,CAAU,UAAd,EAA0B;AACxB,UAAI,OAAA,IAAW,OAAA,CAAQ,OAAR,KAAoB,WAA/B,IAA8C,OAAA,CAAQ,UAA1D,EAAsE;AACpE,cAAM,QAAA,GAAW,KAAK,eAAL,CAAqB,OAAA,CAAQ,UAA7B,CAAjB;AACA,cAAM,MAAA,GAAS,KAAK,eAAL,CAAqB,GAAG,OAAA,CAAQ,SAAA,IAAa,QAAA,cAA7C,CAAf;AAEA,QAAA,QAAA,IAAY,oBAAoB,MAAA,iBAAuB,QAAA,GAAvD;AAAuD;;AAGzD,MAAA,QAAA,IAAY,eAAe,KAAK,UAAL,CAAgB,SAAA,CAAU,UAAV,CAAqB,KAArC,CAAqC,EAAhE;;AAEA,UAAI,SAAA,CAAU,UAAV,CAAqB,GAAzB,EAA8B;AAC5B,QAAA,QAAA,IAAY,KAAK,KAAK,eAAL,CAAqB,SAAA,CAAU,UAAV,CAAqB,GAA1C,CAA0C,GAA3D;AAA2D,OAD7D,MAEO;AACL,QAAA,QAAA,IAAY,KAAK,KAAK,eAAL,CAAqB,IAArB,CAAqB,GAAtC;AAAsC;;AAGxC,UAAI,SAAA,CAAU,QAAd,EAAwB;AACtB,QAAA,QAAA,IAAY,cAAc,SAAA,CAAU,QAAV,CAAmB,WAAnB,EAAmB,EAA7C;AAA6C;;AAG/C,UAAI,SAAA,CAAU,QAAd,EAAwB;AACtB,QAAA,QAAA,IAAY,cAAc,SAAA,CAAU,QAAV,CAAmB,WAAnB,EAAmB,EAA7C;AAA6C;AAAA;;AAIjD,WAAO,QAAP;AAAO;;AAGT,EAAA,eAAA,CAAgB,UAAhB,EAA4B,OAA5B,EAAqC;AACnC,UAAM,MAAA,GAAS,EAAf;;AAEA,SAAA,MAAW,GAAX,IAAkB,UAAlB,EAA8B;AAC5B,YAAM,SAAA,GAAY,UAAA,CAAW,GAAX,CAAlB;AACA,MAAA,MAAA,CAAO,SAAA,CAAU,KAAV,IAAmB,GAA1B,CAAA,GAAiC,KAAK,cAAL,CAAoB,SAApB,EAA+B,OAA/B,CAAjC;AAAgE;;AAGlE,WAAO,MAAP;AAAO;;AAWT,EAAA,wBAAA,CAAyB,IAAzB,EAA+B;AAC7B,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAO,KAAP;AAAO;;AAGT,QAAI,YAAA,GAAe,CAAnB;AACA,QAAI,eAAA,GAAkB,CAAtB;AACA,QAAI,eAAA,GAAkB,CAAtB;AACA,QAAI,eAAA,GAAkB,KAAtB;AACA,QAAI,eAAA,GAAkB,KAAtB;;AAEA,WAAO,YAAA,GAAe,IAAA,CAAK,MAA3B,EAAmC;AACjC,YAAM,MAAA,GAAS,IAAA,CAAK,MAAL,CAAY,YAAZ,CAAf;AACA,YAAM,eAAA,GAAkB,mBAAA,CAAoB,IAApB,CAAyB,MAAzB,CAAxB;;AACA,UAAI,eAAJ,EAAqB;AACnB,QAAA,YAAA,IAAgB,eAAA,CAAgB,CAAhB,CAAA,CAAmB,OAAnB,CAA2B,GAA3B,CAAhB;AACA,QAAA,eAAA,GAAkB,IAAlB;AACA;AAAA;;AAGF,YAAM,eAAA,GAAkB,mBAAA,CAAoB,IAApB,CAAyB,MAAzB,CAAxB;;AACA,UAAI,eAAJ,EAAqB;AACnB,QAAA,YAAA,IAAgB,eAAA,CAAgB,CAAhB,CAAA,CAAmB,MAAnC;AACA,QAAA,eAAA,GAAkB,IAAlB;AACA;AAAA;;AAGF,YAAM,YAAA,GAAe,mBAAA,CAAoB,IAApB,CAAyB,MAAzB,CAArB;;AACA,UAAI,YAAJ,EAAkB;AAChB,cAAM,aAAA,GAAgB,YAAA,CAAa,CAAb,CAAtB;;AACA,YAAI,aAAA,KAAkB,GAAtB,EAA2B;AACzB,UAAA,eAAA;AAAA,SADF,MACE,IACS,aAAA,KAAkB,GAD3B,EACgC;AAChC,UAAA,eAAA;AAAA,SAFA,MAEA,IACS,aAAA,KAAkB,GAD3B,EACgC;AAChC,UAAA,eAAA,GAAkB,IAAlB;AACA;AAAA;;AAEF,QAAA,YAAA,IAAgB,YAAA,CAAa,CAAb,CAAA,CAAgB,MAAhC;AACA;AAAA;;AAGF;AAAA;;AAIF,QAAI,eAAA,KAAoB,eAAA,IAAmB,eAAA,KAAoB,eAA3D,CAAJ,EAAiF;AAC/E,YAAM,IAAI,KAAJ,CAAU,2BAA2B,IAAA,EAArC,CAAN;AAA2C;;AAI7C,WAAO,eAAP;AAAO;;AAGT,EAAA,eAAA,CAAgB,SAAhB,EAA2B,IAA3B,EAAiC,QAAjC,EAA2C;AACzC,QAAI,QAAA,CAAS,QAAT,CAAkB,aAAlB,CAAJ,EAAsC;AACpC,MAAA,QAAA,GAAW,QAAA,CAAS,OAAT,CAAiB,aAAjB,EAAgC,EAAhC,CAAX;AAA2C;;AAG7C,QAAI,QAAA,CAAS,QAAT,CAAkB,QAAlB,CAAJ,EAAiC;AAC/B,UAAI,QAAA,CAAS,QAAT,CAAkB,QAAlB,CAAJ,EAAiC;AAC/B,QAAA,QAAA,GAAW,QAAA,CAAS,OAAT,CAAiB,QAAjB,EAA2B,WAA3B,CAAX;AACA,QAAA,QAAA,GAAW,QAAA,CAAS,OAAT,CAAiB,QAAjB,EAA2B,EAA3B,CAAX;AAAsC,OAFxC,MAEwC,IAC7B,QAAA,CAAS,QAAT,CAAkB,UAAlB,CAD6B,EACE;AACxC,QAAA,QAAA,GAAW,QAAA,CAAS,OAAT,CAAiB,QAAjB,EAA2B,aAA3B,CAAX;AACA,QAAA,QAAA,GAAW,QAAA,CAAS,OAAT,CAAiB,UAAjB,EAA6B,EAA7B,CAAX;AAAwC,OAHF,MAIjC;AACL,QAAA,QAAA,GAAW,QAAA,CAAS,OAAT,CAAiB,SAAjB,EAA4B,EAA5B,CAAX;AAAuC;;AAEzC,MAAA,QAAA,GAAW,QAAA,CAAS,OAAT,CAAiB,UAAjB,EAA6B,EAA7B,CAAX;AAAwC;;AAG1C,WAAO,QAAP;AAAO;;AAWT,EAAA,mBAAA,CAAoB,KAApB,EAA2B,UAA3B,EAAuC;AACrC,UAAM,SAAA,GAAY,KAAA,CAAM,SAAN,IAAmB,KAArC;AACA,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,QAD4B,EAE5B,kBAF4B,EAG5B,gEAAgE,SAAA,GAHpC,EAI5B,yDAAyD,UAAA,GAJ7B,EAK5B,uCAL4B,EAM5B,GAN4B,CAAvB,CAAP;AAME;;AAYJ,EAAA,kBAAA,CAAmB,KAAnB,EAA0B,UAA1B,EAAsC;AACpC,UAAM,gBAAA,GAAmB,KAAA,CAAM,MAAN,GAAe,eAAA,CAAgB,KAAA,CAAM,MAAtB,CAAf,GAA+C,EAAxE;AACA,UAAM,eAAA,GAAkB,eAAA,CAAgB,KAAA,CAAM,SAAN,IAAmB,KAAnC,CAAxB;AACA,UAAM,gBAAA,GAAmB,eAAA,CAAgB,UAAhB,CAAzB;AAEA,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,QAD4B,EAE5B,kBAF4B,EAG5B,0CAH4B,EAI5B,SAJ4B,EAK5B,CACE,2BAA2B,eAAA,EAD7B,EAEE,KAAA,CAAM,MAAN,IAAgB,iCAAiC,gBAAA,EAFnD,EAGE,gCAAgC,gBAAA,EAHlC,CAL4B,EAU5B,QAV4B,EAW5B,CACE,gBAAgB,eAAA,EADlB,EAEE,KAAA,CAAM,MAAN,IAAgB,sBAAsB,gBAAA,EAFxC,EAGE,qBAAqB,gBAAA,EAHvB,EAIE,uCAJF,CAX4B,EAiB5B,GAjB4B,CAAvB,CAAP;AAiBE;;AAYJ,EAAA,mBAAA,CAAoB,SAApB,EAA+B,UAA/B,EAA2C;AACzC,WAAO,KAAA,CAAM,gBAAN,CAAuB,CAC5B,aAD4B,EAE5B,KAAK,UAAL,CAAgB,SAAhB,CAF4B,EAG5B,kBAH4B,EAI5B,KAAK,eAAL,CAAqB,UAArB,CAJ4B,EAK5B,GAL4B,CAAvB,CAAP;AAKE;;AAIJ,EAAA,iBAAA,CAAkB,OAAlB,EAA2B;AACzB,QAAI,QAAA,GAAW,EAAf;;AACA,QAAI,OAAA,CAAQ,MAAR,KAAmB,IAAnB,IAA2B,OAAA,CAAQ,MAAR,KAAmB,KAAA,CAA9C,IAA2D,OAAA,CAAQ,MAAR,KAAmB,CAAlF,EAAqF;AACnF,MAAA,QAAA,GAAW,QAAA,CAAS,MAAT,CAAgB,CAAC,SAAD,EAAY,KAAK,MAAL,CAAY,OAAA,CAAQ,KAApB,CAAZ,EAAwC,UAAxC,EAAoD,KAAK,MAAL,CAAY,OAAA,CAAQ,MAApB,CAApD,CAAhB,CAAX;AAAmG,KADrG,MACqG,IACzF,OAAA,CAAQ,KAAR,KAAkB,IAAlB,IAA0B,OAAA,CAAQ,KAAR,KAAkB,KAAA,CAD6C,EACjC;AAClE,MAAA,QAAA,GAAW,CAAC,SAAD,EAAY,KAAK,MAAL,CAAY,OAAA,CAAQ,KAApB,CAAZ,CAAX;AAA2C;;AAE7C,WAAO,QAAA,CAAS,IAAT,CAAc,EAAd,CAAP;AAAqB;;AAWvB,EAAA,eAAA,CAAgB,UAAhB,EAA4B,KAA5B,EAAmC;AACjC,UAAM,aAAA,GAAgB,KAAA,IAAS,KAA/B;AACA,UAAM,mBAAA,GAAsB,KAAK,OAAL,CAAa,gBAAb,KAAkC,KAA9D;AACA,UAAM,aAAA,GAAgB,KAAA,CAAM,WAAN,CAAkB,UAAlB,EAA8B,GAA9B,CAAtB;;AAEA,QACE,aAAA,KAAkB,IAAlB,IACA,mBAAA,KAAwB,KADxB,IAEA,UAAA,CAAW,QAAX,CAAoB,GAApB,CAFA,IAGA,UAAA,CAAW,QAAX,CAAoB,IAApB,CAHA,IAIA,wBAAA,CAAyB,QAAzB,CAAkC,aAAA,CAAc,WAAd,EAAlC,CALF,EAME;AAMA,aAAO,KAAA,CAAM,QAAN,CAAe,aAAf,EAA8B,GAA9B,CAAP;AAAqC;;AAEvC,WAAO,aAAP;AAAO;;AA1nBkD;;AA+nB7D,SAAA,eAAA,CAAyB,UAAzB,EAAqC;AACnC,SAAO,KAAA,CAAM,QAAN,CAAe,UAAf,EAA2B,GAA3B,CAAP;AAAkC;;AAGpC,MAAA,CAAO,OAAP,GAAiB,uBAAjB","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  'CONSTRAINT_NAME as constraint_name',\n  'CONSTRAINT_NAME as constraintName',\n  'CONSTRAINT_SCHEMA as constraintSchema',\n  'CONSTRAINT_SCHEMA as constraintCatalog',\n  'TABLE_NAME as tableName',\n  'TABLE_SCHEMA as tableSchema',\n  'TABLE_SCHEMA as tableCatalog',\n  'COLUMN_NAME as columnName',\n  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n  'REFERENCED_TABLE_NAME as referencedTableName',\n  'REFERENCED_COLUMN_NAME as referencedColumnName'\n].join(',');\n\n/**\n * list of reserved words in Snowflake\n * source: https://docs.snowflake.com/en/sql-reference/reserved-keywords.html\n *\n * @private\n */\nconst SNOWFLAKE_RESERVED_WORDS = 'account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with'.split(',');\n  \nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = {\n      ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n\n    return Utils.joinSQLFragments([\n      'CREATE DATABASE IF NOT EXISTS',\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      ';'\n    ]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT CURRENT_VERSION()';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'CREATE TABLE IF NOT EXISTS',\n      table,\n      `(${attributesClause})`,\n      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      ';'\n    ]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\n      'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'',\n      database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : 'AND TABLE_SCHEMA NOT IN ( \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')',\n      ';'\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      }),\n      ';'\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'ALTER COLUMN',\n      ...subQuerys,\n      ';'\n    ]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n\n      if (definition.includes('NOT NULL')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'SET NOT NULL'));\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'DROP NOT NULL'));\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'SET DEFAULT', definition.match(/DEFAULT ([^;]+)/)[1]));\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'DROP DEFAULT'));\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql.push(query('ADD UNIQUE (', this.quoteIdentifier(attributeName), ')').replace('ALTER COLUMN', ''));\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql.push(query('ADD FOREIGN KEY (', this.quoteIdentifier(attributeName), ')', definition).replace('ALTER COLUMN', ''));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'TYPE', definition));\n      }\n\n      sql.push(attrSql.join(''));\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'RENAME COLUMN',\n      attrString.join(' to '),\n      ';'\n    ]);\n  }\n\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      // Parse nested object\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (attr.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (attr.value) {\n          str += util.format(' = %s', this.escape(attr.value));\n        }\n\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = 'datetime';\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        attr.type = 'char';\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = 'decimal';\n      } else if (/text/i.test(attr.type)) {\n        attr.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      'TRUNCATE',\n      this.quoteTable(tableName)\n    ]);\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return Utils.joinSQLFragments([\n        'DELETE FROM',\n        table,\n        'WHERE',\n        primaryKeys,\n        'IN (SELECT',\n        primaryKeysSelection,\n        'FROM',\n        table,\n        whereClause,\n        limit,\n        ')',\n        ';'\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      'DELETE FROM',\n      table,\n      whereClause,\n      ';'\n    ]);\n  }\n\n  showIndexesQuery() {\n    return 'SELECT \\'\\' FROM DUAL';\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      ';'\n    ]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'DROP INDEX',\n      this.quoteIdentifier(indexName),\n      'ON',\n      this.quoteTable(tableName),\n      ';'\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' AUTOINCREMENT';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      'AND REFERENCED_TABLE_NAME IS NOT NULL',\n      ';'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',\n      'WHERE (',\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      ') OR (',\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        'AND REFERENCED_TABLE_NAME IS NOT NULL'\n      ],\n      ')'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP FOREIGN KEY',\n      this.quoteIdentifier(foreignKey),\n      ';'\n    ]);\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== undefined && options.offset !== 0) {\n      fragment = fragment.concat([' LIMIT ', this.escape(options.limit), ' OFFSET ', this.escape(options.offset)]);\n    } else if ( options.limit !== null && options.limit !== undefined ) {\n      fragment = [' LIMIT ', this.escape(options.limit)];\n    }\n    return fragment.join('');\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n    if (\n      optForceQuote === true ||\n      optQuoteIdentifiers !== false ||\n      identifier.includes('.') ||\n      identifier.includes('->') ||\n      SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())\n    ) {\n      // In Snowflake if tables or attributes are created double-quoted,\n      // they are also case sensitive. If they contain any uppercase\n      // characters, they must always be double-quoted. This makes it\n      // impossible to write queries in portable SQL if tables are created in\n      // this way. Hence, we strip quotes if we don't want case sensitivity.\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = SnowflakeQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}