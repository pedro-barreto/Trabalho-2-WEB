{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst wkx = require(\"wkx\");\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"http://www.postgresql.org/docs/9.4/static/datatype.html\");\n\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n\n  BaseTypes.UUID.types.postgres = [\"uuid\"];\n  BaseTypes.CIDR.types.postgres = [\"cidr\"];\n  BaseTypes.INET.types.postgres = [\"inet\"];\n  BaseTypes.MACADDR.types.postgres = [\"macaddr\"];\n  BaseTypes.TSVECTOR.types.postgres = [\"tsvector\"];\n  BaseTypes.JSON.types.postgres = [\"json\"];\n  BaseTypes.JSONB.types.postgres = [\"jsonb\"];\n  BaseTypes.TIME.types.postgres = [\"time\"];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n\n      return super._stringify(value, options);\n    }\n\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n\n        return super._sanitize(value);\n      }\n\n      return value;\n    }\n\n    static parse(value) {\n      if (value === \"infinity\") {\n        return Infinity;\n      }\n\n      if (value === \"-infinity\") {\n        return -Infinity;\n      }\n\n      return value;\n    }\n\n  }\n\n  BaseTypes.DATEONLY.types.postgres = [\"date\"];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.DECIMAL.types.postgres = [\"numeric\"];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n\n      return super.toSql();\n    }\n\n  }\n\n  BaseTypes.STRING.types.postgres = [\"varchar\"];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n\n      return \"TEXT\";\n    }\n\n  }\n\n  BaseTypes.TEXT.types.postgres = [\"text\"];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.CITEXT.types.postgres = [\"citext\"];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n\n      return super.toSql();\n    }\n\n  }\n\n  BaseTypes.CHAR.types.postgres = [\"char\", \"bpchar\"];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n\n        if (typeof value === \"string\") {\n          return [\"true\", \"t\"].includes(value) ? true : [\"false\", \"f\"].includes(value) ? false : value;\n        }\n\n        if (typeof value === \"number\") {\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n\n      return value;\n    }\n\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  BaseTypes.BOOLEAN.types.postgres = [\"bool\"];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH TIME ZONE\";\n    }\n\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n\n      return true;\n    }\n\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n\n      return super._stringify(value, options);\n    }\n\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n\n        return new Date(value);\n      }\n\n      return value;\n    }\n\n  }\n\n  BaseTypes.DATE.types.postgres = [\"timestamptz\"];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.TINYINT.types.postgres = [\"int2\"];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.SMALLINT.types.postgres = [\"int2\"];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  BaseTypes.INTEGER.types.postgres = [\"int4\"];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.BIGINT.types.postgres = [\"int8\"];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.REAL.types.postgres = [\"float4\"];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  BaseTypes.DOUBLE.types.postgres = [\"float8\"];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n\n      if (this._decimals) {\n        warn(\"PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._decimals = void 0;\n      }\n\n      if (this._unsigned) {\n        warn(\"PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n\n      if (this._zerofill) {\n        warn(\"PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n\n  }\n\n  delete FLOAT.parse;\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.\");\n        this._length = void 0;\n      }\n\n      return \"BYTEA\";\n    }\n\n    _hexify(hex) {\n      return `E'\\\\\\\\x${hex}'`;\n    }\n\n  }\n\n  BaseTypes.BLOB.types.postgres = [\"bytea\"];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n\n      if (this.type) {\n        result += `(${this.type}`;\n\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n\n        result += \")\";\n      }\n\n      return result;\n    }\n\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({\n        shortCrs: true\n      });\n    }\n\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = [\"geometry\"];\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = \"GEOGRAPHY\";\n\n      if (this.type) {\n        result += `(${this.type}`;\n\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n\n        result += \")\";\n      }\n\n      return result;\n    }\n\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({\n        shortCrs: true\n      });\n    }\n\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = [\"geography\"];\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n\n      if (!hstore) {\n        hstore = require(\"./hstore\");\n      }\n    }\n\n    _value(value) {\n      if (!hstore) {\n        hstore = require(\"./hstore\");\n      }\n\n      return hstore.stringify(value);\n    }\n\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n\n    static parse(value) {\n      if (!hstore) {\n        hstore = require(\"./hstore\");\n      }\n\n      return hstore.parse(value);\n    }\n\n  }\n\n  HSTORE.prototype.escape = false;\n  BaseTypes.HSTORE.types.postgres = [\"hstore\"];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\")) {\n          if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) {\n            valueInclusivity[index] = value.inclusive;\n          }\n\n          value = value.value;\n        }\n\n        if (value === null || value === -Infinity || value === Infinity) {\n          return value;\n        }\n\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n\n        return options.escape(value);\n      });\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n\n    _stringify(values, options) {\n      const value = this._value(values, options);\n\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n\n      return `'${value}'`;\n    }\n\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n\n      return options.bindParam(value);\n    }\n\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n\n    static parse(value) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        parser: val => val\n      };\n      return range.parse(value, options.parser);\n    }\n\n  }\n\n  const range = require(\"./range\");\n\n  RANGE.prototype.escape = false;\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: \"int4range\",\n      decimal: \"numrange\",\n      date: \"tstzrange\",\n      dateonly: \"daterange\",\n      bigint: \"int8range\"\n    },\n    castTypes: {\n      integer: \"int4\",\n      decimal: \"numeric\",\n      date: \"timestamptz\",\n      dateonly: \"date\",\n      bigint: \"int8\"\n    }\n  };\n  BaseTypes.ARRAY.prototype.escape = false;\n\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n\n      return options.escape(value);\n    }, this);\n  };\n\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(\",\")}]`;\n\n    if (this.type) {\n      const Utils = require(\"../../utils\");\n\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        const table = options.field.Model.getTableName();\n        const useSchema = table.schema !== void 0;\n        const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '\"')}${table.delimiter}` : \"\";\n        castKey = `${Utils.addTicks(Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field), '\"')}[]`;\n        str += `::${schemaWithDelimiter}${castKey}`;\n      } else {\n        str += `::${castKey}`;\n      }\n    }\n\n    return str;\n  };\n\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};","map":{"version":3,"sources":["C:\\Users\\Pedro\\codigos\\Trabalho-2-WEB\\frontend\\node_modules\\sequelize\\lib\\dialects\\postgres\\data-types.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst wkx = require('wkx');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n\n  /**\n   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * types:\n   * {\n   *   oids: [oid],\n   *   array_oids: [oid]\n   * }\n   *\n   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go\n   */\n\n  BaseTypes.UUID.types.postgres = ['uuid'];\n  BaseTypes.CIDR.types.postgres = ['cidr'];\n  BaseTypes.INET.types.postgres = ['inet'];\n  BaseTypes.MACADDR.types.postgres = ['macaddr'];\n  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];\n  BaseTypes.JSON.types.postgres = ['json'];\n  BaseTypes.JSONB.types.postgres = ['jsonb'];\n  BaseTypes.TIME.types.postgres = ['time'];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === 'infinity') {\n        return Infinity;\n      }\n      if (value === '-infinity') {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATEONLY.types.postgres = ['date'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  // numeric\n  BaseTypes.DECIMAL.types.postgres = ['numeric'];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.STRING.types.postgres = ['varchar'];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n      return 'TEXT';\n    }\n  }\n\n  BaseTypes.TEXT.types.postgres = ['text'];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.CITEXT.types.postgres = ['citext'];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BOOLEAN';\n    }\n    _sanitize(value) {\n      if (value !== null && value !== undefined) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          // Bit fields are returned as buffers\n          value = value[0];\n        }\n        if (typeof value === 'string') {\n          // Only take action on valid boolean strings.\n          return ['true', 't'].includes(value) ? true : ['false', 'f'].includes(value) ? false : value;\n        }\n        if (typeof value === 'number') {\n          // Only take action on valid boolean integers.\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n  BaseTypes.BOOLEAN.types.postgres = ['bool'];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH TIME ZONE';\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATE.types.postgres = ['timestamptz'];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.TINYINT.types.postgres = ['int2'];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.SMALLINT.types.postgres = ['int2'];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  // int4\n  BaseTypes.INTEGER.types.postgres = ['int4'];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int8\n  BaseTypes.BIGINT.types.postgres = ['int8'];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float4\n  BaseTypes.REAL.types.postgres = ['float4'];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float8\n  BaseTypes.DOUBLE.types.postgres = ['float8'];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      // POSTGRES does only support lengths as parameter.\n      // Values between 1-24 result in REAL\n      // Values between 25-53 result in DOUBLE PRECISION\n      // If decimals are provided remove these and print a warning\n      if (this._decimals) {\n        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._decimals = undefined;\n      }\n      if (this._unsigned) {\n        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n        this._unsigned = undefined;\n      }\n      if (this._zerofill) {\n        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n        this._zerofill = undefined;\n      }\n    }\n  }\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n        this._length = undefined;\n      }\n      return 'BYTEA';\n    }\n    _hexify(hex) {\n      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n\n  BaseTypes.BLOB.types.postgres = ['bytea'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = ['geometry'];\n\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = 'GEOGRAPHY';\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];\n\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.parse(value);\n    }\n  }\n\n  HSTORE.prototype.escape = false;\n\n  BaseTypes.HSTORE.types.postgres = ['hstore'];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {\n          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          // Pass through \"unbounded\" bounds unchanged\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      // Array.map does not preserve extra array properties\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: val => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = require('./range');\n\n  RANGE.prototype.escape = false;\n\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range'\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8'\n    }\n  };\n\n  // TODO: Why are base types being manipulated??\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(',')}]`;\n\n    if (this.type) {\n      const Utils = require('../../utils');\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        const table = options.field.Model.getTableName();\n        const useSchema = table.schema !== undefined;\n        const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '\"')}${table.delimiter}` : '';\n\n        castKey = `${Utils.addTicks(\n          Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field),\n          '\"'\n        ) }[]`;\n\n        str += `::${schemaWithDelimiter}${castKey}`;\n      } else {\n        str += `::${castKey}`;\n      }\n    }\n\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n"]},"metadata":{},"sourceType":"script"}